// Code generated by go-swagger; DO NOT EDIT.

package user_data

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"

	strfmt "github.com/go-openapi/strfmt"
)

// RegisterReader is a Reader for the Register structure.
type RegisterReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *RegisterReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewRegisterOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewRegisterBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 401:
		result := NewRegisterUnauthorized()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 403:
		result := NewRegisterForbidden()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 429:
		result := NewRegisterTooManyRequests()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result

	default:
		return nil, runtime.NewAPIError("unknown error", response, response.Code())
	}
}

// NewRegisterOK creates a RegisterOK with default headers values
func NewRegisterOK() *RegisterOK {
	return &RegisterOK{}
}

/*RegisterOK handles this case with default header values.

The account has been registered.
*/
type RegisterOK struct {
	Payload *RegisterOKBody
}

func (o *RegisterOK) Error() string {
	return fmt.Sprintf("[POST /_matrix/client/unstable/register][%d] registerOK  %+v", 200, o.Payload)
}

func (o *RegisterOK) GetPayload() *RegisterOKBody {
	return o.Payload
}

func (o *RegisterOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(RegisterOKBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewRegisterBadRequest creates a RegisterBadRequest with default headers values
func NewRegisterBadRequest() *RegisterBadRequest {
	return &RegisterBadRequest{}
}

/*RegisterBadRequest handles this case with default header values.

Part of the request was invalid. This may include one of the following error codes:

* ``M_USER_IN_USE`` : The desired user ID is already taken.
* ``M_INVALID_USERNAME`` : The desired user ID is not a valid user name.
* ``M_EXCLUSIVE`` : The desired user ID is in the exclusive namespace
  claimed by an application service.

These errors may be returned at any stage of the registration process,
including after authentication if the requested user ID was registered
whilst the client was performing authentication.

Homeservers MUST perform the relevant checks and return these codes before
performing User-Interactive Authentication, although they may also return
them after authentication is completed if, for example, the requested user ID
was registered whilst the client was performing authentication.
*/
type RegisterBadRequest struct {
	Payload *RegisterBadRequestBody
}

func (o *RegisterBadRequest) Error() string {
	return fmt.Sprintf("[POST /_matrix/client/unstable/register][%d] registerBadRequest  %+v", 400, o.Payload)
}

func (o *RegisterBadRequest) GetPayload() *RegisterBadRequestBody {
	return o.Payload
}

func (o *RegisterBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(RegisterBadRequestBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewRegisterUnauthorized creates a RegisterUnauthorized with default headers values
func NewRegisterUnauthorized() *RegisterUnauthorized {
	return &RegisterUnauthorized{}
}

/*RegisterUnauthorized handles this case with default header values.

The homeserver requires additional authentication information.
*/
type RegisterUnauthorized struct {
	Payload *RegisterUnauthorizedBody
}

func (o *RegisterUnauthorized) Error() string {
	return fmt.Sprintf("[POST /_matrix/client/unstable/register][%d] registerUnauthorized  %+v", 401, o.Payload)
}

func (o *RegisterUnauthorized) GetPayload() *RegisterUnauthorizedBody {
	return o.Payload
}

func (o *RegisterUnauthorized) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(RegisterUnauthorizedBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewRegisterForbidden creates a RegisterForbidden with default headers values
func NewRegisterForbidden() *RegisterForbidden {
	return &RegisterForbidden{}
}

/*RegisterForbidden handles this case with default header values.

The homeserver does not permit registering the account. This response
can be used to identify that a particular ``kind`` of account is not
allowed, or that registration is generally not supported by the homeserver.
*/
type RegisterForbidden struct {
	Payload *RegisterForbiddenBody
}

func (o *RegisterForbidden) Error() string {
	return fmt.Sprintf("[POST /_matrix/client/unstable/register][%d] registerForbidden  %+v", 403, o.Payload)
}

func (o *RegisterForbidden) GetPayload() *RegisterForbiddenBody {
	return o.Payload
}

func (o *RegisterForbidden) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(RegisterForbiddenBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewRegisterTooManyRequests creates a RegisterTooManyRequests with default headers values
func NewRegisterTooManyRequests() *RegisterTooManyRequests {
	return &RegisterTooManyRequests{}
}

/*RegisterTooManyRequests handles this case with default header values.

This request was rate-limited.
*/
type RegisterTooManyRequests struct {
	Payload *RegisterTooManyRequestsBody
}

func (o *RegisterTooManyRequests) Error() string {
	return fmt.Sprintf("[POST /_matrix/client/unstable/register][%d] registerTooManyRequests  %+v", 429, o.Payload)
}

func (o *RegisterTooManyRequests) GetPayload() *RegisterTooManyRequestsBody {
	return o.Payload
}

func (o *RegisterTooManyRequests) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(RegisterTooManyRequestsBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*RegisterBadRequestBody A Matrix-level Error
swagger:model RegisterBadRequestBody
*/
type RegisterBadRequestBody struct {

	// An error code.
	// Required: true
	Errcode *string `json:"errcode"`

	// A human-readable error message.
	Error string `json:"error,omitempty"`
}

// Validate validates this register bad request body
func (o *RegisterBadRequestBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrcode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RegisterBadRequestBody) validateErrcode(formats strfmt.Registry) error {

	if err := validate.Required("registerBadRequest"+"."+"errcode", "body", o.Errcode); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RegisterBadRequestBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RegisterBadRequestBody) UnmarshalBinary(b []byte) error {
	var res RegisterBadRequestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RegisterBody register body
swagger:model RegisterBody
*/
type RegisterBody struct {

	// auth
	Auth *RegisterParamsBodyAuth `json:"auth,omitempty"`

	// ID of the client device. If this does not correspond to a
	// known client device, a new device will be created. The server
	// will auto-generate a device_id if this is not specified.
	DeviceID string `json:"device_id,omitempty"`

	// If true, an ``access_token`` and ``device_id`` should not be
	// returned from this call, therefore preventing an automatic
	// login. Defaults to false.
	InhibitLogin bool `json:"inhibit_login,omitempty"`

	// A display name to assign to the newly-created device. Ignored
	// if ``device_id`` corresponds to a known device.
	InitialDeviceDisplayName string `json:"initial_device_display_name,omitempty"`

	// The desired password for the account.
	Password string `json:"password,omitempty"`

	// The basis for the localpart of the desired Matrix ID. If omitted,
	// the homeserver MUST generate a Matrix ID local part.
	Username string `json:"username,omitempty"`
}

// Validate validates this register body
func (o *RegisterBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAuth(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RegisterBody) validateAuth(formats strfmt.Registry) error {

	if swag.IsZero(o.Auth) { // not required
		return nil
	}

	if o.Auth != nil {
		if err := o.Auth.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("body" + "." + "auth")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RegisterBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RegisterBody) UnmarshalBinary(b []byte) error {
	var res RegisterBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RegisterForbiddenBody A Matrix-level Error
swagger:model RegisterForbiddenBody
*/
type RegisterForbiddenBody struct {

	// An error code.
	// Required: true
	Errcode *string `json:"errcode"`

	// A human-readable error message.
	Error string `json:"error,omitempty"`
}

// Validate validates this register forbidden body
func (o *RegisterForbiddenBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrcode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RegisterForbiddenBody) validateErrcode(formats strfmt.Registry) error {

	if err := validate.Required("registerForbidden"+"."+"errcode", "body", o.Errcode); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RegisterForbiddenBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RegisterForbiddenBody) UnmarshalBinary(b []byte) error {
	var res RegisterForbiddenBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RegisterOKBody register o k body
swagger:model RegisterOKBody
*/
type RegisterOKBody struct {

	// An access token for the account.
	// This access token can then be used to authorize other requests.
	// Required if the ``inhibit_login`` option is false.
	AccessToken string `json:"access_token,omitempty"`

	// ID of the registered device. Will be the same as the
	// corresponding parameter in the request, if one was specified.
	// Required if the ``inhibit_login`` option is false.
	DeviceID string `json:"device_id,omitempty"`

	// The server_name of the homeserver on which the account has
	// been registered.
	//
	// **Deprecated**. Clients should extract the server_name from
	// ``user_id`` (by splitting at the first colon) if they require
	// it. Note also that ``homeserver`` is not spelt this way.
	HomeServer string `json:"home_server,omitempty"`

	// The fully-qualified Matrix user ID (MXID) that has been registered.
	//
	// Any user ID returned by this API must conform to the grammar given in the
	// `Matrix specification <../appendices.html#user-identifiers>`_.
	// Required: true
	UserID *string `json:"user_id"`
}

// Validate validates this register o k body
func (o *RegisterOKBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateUserID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RegisterOKBody) validateUserID(formats strfmt.Registry) error {

	if err := validate.Required("registerOK"+"."+"user_id", "body", o.UserID); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RegisterOKBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RegisterOKBody) UnmarshalBinary(b []byte) error {
	var res RegisterOKBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RegisterParamsBodyAuth Authentication Data
//
// Additional authentication information for the
// user-interactive authentication API. Note that this
// information is *not* used to define how the registered user
// should be authenticated, but is instead used to
// authenticate the ``register`` call itself.
swagger:model RegisterParamsBodyAuth
*/
type RegisterParamsBodyAuth struct {

	// The value of the session key given by the homeserver.
	Session string `json:"session,omitempty"`

	// The login type that the client is attempting to complete.
	// Required: true
	Type *string `json:"type"`

	// Keys dependent on the login type
	RegisterParamsBodyAuth map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (o *RegisterParamsBodyAuth) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// The value of the session key given by the homeserver.
		Session string `json:"session,omitempty"`

		// The login type that the client is attempting to complete.
		// Required: true
		Type *string `json:"type"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv RegisterParamsBodyAuth

	rcv.Session = stage1.Session

	rcv.Type = stage1.Type

	*o = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "session")

	delete(stage2, "type")

	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		o.RegisterParamsBodyAuth = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (o RegisterParamsBodyAuth) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// The value of the session key given by the homeserver.
		Session string `json:"session,omitempty"`

		// The login type that the client is attempting to complete.
		// Required: true
		Type *string `json:"type"`
	}

	stage1.Session = o.Session

	stage1.Type = o.Type

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(o.RegisterParamsBodyAuth) == 0 {
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(o.RegisterParamsBodyAuth)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 {
		return additional, nil
	}

	// concatenate the 2 objects
	props[len(props)-1] = ','
	return append(props, additional[1:]...), nil
}

// Validate validates this register params body auth
func (o *RegisterParamsBodyAuth) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RegisterParamsBodyAuth) validateType(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"auth"+"."+"type", "body", o.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RegisterParamsBodyAuth) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RegisterParamsBodyAuth) UnmarshalBinary(b []byte) error {
	var res RegisterParamsBodyAuth
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RegisterTooManyRequestsBody The rate limit was reached for this request
swagger:model RegisterTooManyRequestsBody
*/
type RegisterTooManyRequestsBody struct {

	// The M_LIMIT_EXCEEDED error code
	// Required: true
	Errcode *string `json:"errcode"`

	// A human-readable error message.
	Error string `json:"error,omitempty"`

	// The amount of time in milliseconds the client should wait
	// before trying the request again.
	RetryAfterMs int64 `json:"retry_after_ms,omitempty"`
}

// Validate validates this register too many requests body
func (o *RegisterTooManyRequestsBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrcode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RegisterTooManyRequestsBody) validateErrcode(formats strfmt.Registry) error {

	if err := validate.Required("registerTooManyRequests"+"."+"errcode", "body", o.Errcode); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RegisterTooManyRequestsBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RegisterTooManyRequestsBody) UnmarshalBinary(b []byte) error {
	var res RegisterTooManyRequestsBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RegisterUnauthorizedBody Authentication response
//
// Used by servers to indicate that additional authentication information is required,
swagger:model RegisterUnauthorizedBody
*/
type RegisterUnauthorizedBody struct {

	// A list of the stages the client has completed successfully
	Completed []string `json:"completed"`

	// Flow information
	//
	// A list of the login flows supported by the server for this API.
	// Required: true
	Flows []*FlowsItems0 `json:"flows"`

	// Contains any information that the client will need to know in order to
	// use a given type of authentication. For each login type presented,
	// that type may be present as a key in this dictionary. For example, the
	// public part of an OAuth client ID could be given here.
	Params map[string]interface{} `json:"params,omitempty"`

	// This is a session identifier that the client must pass back to the home
	// server, if one is provided, in subsequent attempts to authenticate in the
	// same API call.
	Session string `json:"session,omitempty"`
}

// Validate validates this register unauthorized body
func (o *RegisterUnauthorizedBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateFlows(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RegisterUnauthorizedBody) validateFlows(formats strfmt.Registry) error {

	if err := validate.Required("registerUnauthorized"+"."+"flows", "body", o.Flows); err != nil {
		return err
	}

	for i := 0; i < len(o.Flows); i++ {
		if swag.IsZero(o.Flows[i]) { // not required
			continue
		}

		if o.Flows[i] != nil {
			if err := o.Flows[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("registerUnauthorized" + "." + "flows" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *RegisterUnauthorizedBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RegisterUnauthorizedBody) UnmarshalBinary(b []byte) error {
	var res RegisterUnauthorizedBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
