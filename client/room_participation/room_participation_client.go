// Code generated by go-swagger; DO NOT EDIT.

package room_participation

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new room participation API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for room participation API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
DefineFilter uploads a new filter

Uploads a new filter definition to the homeserver.
Returns a filter ID that may be used in future requests to
restrict which events are returned to the client.
*/
func (a *Client) DefineFilter(params *DefineFilterParams, authInfo runtime.ClientAuthInfoWriter) (*DefineFilterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDefineFilterParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "defineFilter",
		Method:             "POST",
		PathPattern:        "/_matrix/client/unstable/user/{userId}/filter",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DefineFilterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DefineFilterOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for defineFilter: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetEventContext gets events and state around the specified event

This API returns a number of events that happened just before and
after the specified event. This allows clients to get the context
surrounding an event.

*Note*: This endpoint supports lazy-loading of room member events. See
`Lazy-loading room members <#lazy-loading-room-members>`_ for more information.
*/
func (a *Client) GetEventContext(params *GetEventContextParams, authInfo runtime.ClientAuthInfoWriter) (*GetEventContextOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetEventContextParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getEventContext",
		Method:             "GET",
		PathPattern:        "/_matrix/client/unstable/rooms/{roomId}/context/{eventId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetEventContextReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetEventContextOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getEventContext: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetEvents listens on the event stream

This will listen for new events and return them to the caller. This will
block until an event is received, or until the ``timeout`` is reached.

This endpoint was deprecated in r0 of this specification. Clients
should instead call the |/sync|_ API with a ``since`` parameter. See
the `migration guide
<https://matrix.org/docs/guides/client-server-migrating-from-v1.html#deprecated-endpoints>`_.
*/
func (a *Client) GetEvents(params *GetEventsParams, authInfo runtime.ClientAuthInfoWriter) (*GetEventsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetEventsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getEvents",
		Method:             "GET",
		PathPattern:        "/_matrix/client/unstable/events",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetEventsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetEventsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getEvents: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetFilter downloads a filter
*/
func (a *Client) GetFilter(params *GetFilterParams, authInfo runtime.ClientAuthInfoWriter) (*GetFilterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetFilterParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getFilter",
		Method:             "GET",
		PathPattern:        "/_matrix/client/unstable/user/{userId}/filter/{filterId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetFilterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetFilterOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getFilter: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetJoinedMembersByRoom gets the list of currently joined users and their profile data

This API returns a map of MXIDs to member info objects for members of the room. The current user must be in the room for it to work, unless it is an Application Service in which case any of the AS's users must be in the room. This API is primarily for Application Services and should be faster to respond than ``/members`` as it can be implemented more efficiently on the server.
*/
func (a *Client) GetJoinedMembersByRoom(params *GetJoinedMembersByRoomParams, authInfo runtime.ClientAuthInfoWriter) (*GetJoinedMembersByRoomOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetJoinedMembersByRoomParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getJoinedMembersByRoom",
		Method:             "GET",
		PathPattern:        "/_matrix/client/unstable/rooms/{roomId}/joined_members",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetJoinedMembersByRoomReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetJoinedMembersByRoomOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getJoinedMembersByRoom: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetMembersByRoom gets the m room member events for the room

Get the list of members for this room.
*/
func (a *Client) GetMembersByRoom(params *GetMembersByRoomParams, authInfo runtime.ClientAuthInfoWriter) (*GetMembersByRoomOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMembersByRoomParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getMembersByRoom",
		Method:             "GET",
		PathPattern:        "/_matrix/client/unstable/rooms/{roomId}/members",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetMembersByRoomReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMembersByRoomOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getMembersByRoom: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetOneEvent gets a single event by event ID

Get a single event based on ``event_id``. You must have permission to
retrieve this event e.g. by being a member in the room for this event.

This endpoint was deprecated in r0 of this specification. Clients
should instead call the |/rooms/{roomId}/event/{eventId}|_ API
or the |/rooms/{roomId}/context/{eventId}|_ API.
*/
func (a *Client) GetOneEvent(params *GetOneEventParams, authInfo runtime.ClientAuthInfoWriter) (*GetOneEventOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetOneEventParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getOneEvent",
		Method:             "GET",
		PathPattern:        "/_matrix/client/unstable/events/{eventId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetOneEventReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetOneEventOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getOneEvent: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetOneRoomEvent gets a single event by event ID

Get a single event based on ``roomId/eventId``. You must have permission to
retrieve this event e.g. by being a member in the room for this event.
*/
func (a *Client) GetOneRoomEvent(params *GetOneRoomEventParams, authInfo runtime.ClientAuthInfoWriter) (*GetOneRoomEventOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetOneRoomEventParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getOneRoomEvent",
		Method:             "GET",
		PathPattern:        "/_matrix/client/unstable/rooms/{roomId}/event/{eventId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetOneRoomEventReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetOneRoomEventOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getOneRoomEvent: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetRoomEvents gets a list of events for this room

This API returns a list of message and state events for a room. It uses
pagination query parameters to paginate history in the room.

*Note*: This endpoint supports lazy-loading of room member events. See
`Lazy-loading room members <#lazy-loading-room-members>`_ for more information.
*/
func (a *Client) GetRoomEvents(params *GetRoomEventsParams, authInfo runtime.ClientAuthInfoWriter) (*GetRoomEventsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRoomEventsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getRoomEvents",
		Method:             "GET",
		PathPattern:        "/_matrix/client/unstable/rooms/{roomId}/messages",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRoomEventsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRoomEventsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getRoomEvents: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetRoomState gets all state events in the current state of a room

Get the state events for the current state of a room.
*/
func (a *Client) GetRoomState(params *GetRoomStateParams, authInfo runtime.ClientAuthInfoWriter) (*GetRoomStateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRoomStateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getRoomState",
		Method:             "GET",
		PathPattern:        "/_matrix/client/unstable/rooms/{roomId}/state",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRoomStateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRoomStateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getRoomState: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetRoomStateWithKey gets the state identified by the type and key

.. For backwards compatibility with older links...
.. _`get-matrix-client-unstable-rooms-roomid-state-eventtype`:

Looks up the contents of a state event in a room. If the user is
joined to the room then the state is taken from the current
state of the room. If the user has left the room then the state is
taken from the state of the room when they left.
*/
func (a *Client) GetRoomStateWithKey(params *GetRoomStateWithKeyParams, authInfo runtime.ClientAuthInfoWriter) (*GetRoomStateWithKeyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRoomStateWithKeyParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getRoomStateWithKey",
		Method:             "GET",
		PathPattern:        "/_matrix/client/unstable/rooms/{roomId}/state/{eventType}/{stateKey}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRoomStateWithKeyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRoomStateWithKeyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getRoomStateWithKey: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
InitialSync gets the user s current state

This returns the full state for this user, with an optional limit on the
number of messages per room to return.

This endpoint was deprecated in r0 of this specification. Clients
should instead call the |/sync|_ API with no ``since`` parameter. See
the `migration guide
<https://matrix.org/docs/guides/client-server-migrating-from-v1.html#deprecated-endpoints>`_.
*/
func (a *Client) InitialSync(params *InitialSyncParams, authInfo runtime.ClientAuthInfoWriter) (*InitialSyncOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewInitialSyncParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "initialSync",
		Method:             "GET",
		PathPattern:        "/_matrix/client/unstable/initialSync",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &InitialSyncReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*InitialSyncOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for initialSync: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
PostReceipt sends a receipt for the given event ID

This API updates the marker for the given receipt type to the event ID
specified.
*/
func (a *Client) PostReceipt(params *PostReceiptParams, authInfo runtime.ClientAuthInfoWriter) (*PostReceiptOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostReceiptParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postReceipt",
		Method:             "POST",
		PathPattern:        "/_matrix/client/unstable/rooms/{roomId}/receipt/{receiptType}/{eventId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostReceiptReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PostReceiptOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for postReceipt: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RedactEvent strips all non integrity critical information out of an event

Strips all information out of an event which isn't critical to the
integrity of the server-side representation of the room.

This cannot be undone.

Users may redact their own events, and any user with a power level
greater than or equal to the `redact` power level of the room may
redact events there.
*/
func (a *Client) RedactEvent(params *RedactEventParams, authInfo runtime.ClientAuthInfoWriter) (*RedactEventOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRedactEventParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "redactEvent",
		Method:             "PUT",
		PathPattern:        "/_matrix/client/unstable/rooms/{roomId}/redact/{eventId}/{txnId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RedactEventReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RedactEventOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for redactEvent: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RoomInitialSync snapshots the current state of a room and its most recent messages

Get a copy of the current state and the most recent messages in a room.

This endpoint was deprecated in r0 of this specification. There is no
direct replacement; the relevant information is returned by the
|/sync|_ API. See the `migration guide
<https://matrix.org/docs/guides/client-server-migrating-from-v1.html#deprecated-endpoints>`_.
*/
func (a *Client) RoomInitialSync(params *RoomInitialSyncParams, authInfo runtime.ClientAuthInfoWriter) (*RoomInitialSyncOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRoomInitialSyncParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "roomInitialSync",
		Method:             "GET",
		PathPattern:        "/_matrix/client/unstable/rooms/{roomId}/initialSync",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RoomInitialSyncReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RoomInitialSyncOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for roomInitialSync: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
SendMessage sends a message event to the given room

This endpoint is used to send a message event to a room. Message events
allow access to historical events and pagination, making them suited
for "once-off" activity in a room.

The body of the request should be the content object of the event; the
fields in this object will vary depending on the type of event. See
`Room Events`_ for the m. event specification.
*/
func (a *Client) SendMessage(params *SendMessageParams, authInfo runtime.ClientAuthInfoWriter) (*SendMessageOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSendMessageParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "sendMessage",
		Method:             "PUT",
		PathPattern:        "/_matrix/client/unstable/rooms/{roomId}/send/{eventType}/{txnId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SendMessageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SendMessageOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for sendMessage: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
SetRoomStateWithKey sends a state event to the given room

.. For backwards compatibility with older links...
.. _`put-matrix-client-unstable-rooms-roomid-state-eventtype`:

State events can be sent using this endpoint.  These events will be
overwritten if ``<room id>``, ``<event type>`` and ``<state key>`` all
match.

Requests to this endpoint **cannot use transaction IDs**
like other ``PUT`` paths because they cannot be differentiated from the
``state_key``. Furthermore, ``POST`` is unsupported on state paths.

The body of the request should be the content object of the event; the
fields in this object will vary depending on the type of event. See
`Room Events`_ for the ``m.`` event specification.

*/
func (a *Client) SetRoomStateWithKey(params *SetRoomStateWithKeyParams, authInfo runtime.ClientAuthInfoWriter) (*SetRoomStateWithKeyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSetRoomStateWithKeyParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "setRoomStateWithKey",
		Method:             "PUT",
		PathPattern:        "/_matrix/client/unstable/rooms/{roomId}/state/{eventType}/{stateKey}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SetRoomStateWithKeyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SetRoomStateWithKeyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for setRoomStateWithKey: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
SetTyping informs the server that the user has started or stopped typing

This tells the server that the user is typing for the next N
milliseconds where N is the value specified in the ``timeout`` key.
Alternatively, if ``typing`` is ``false``, it tells the server that the
user has stopped typing.
*/
func (a *Client) SetTyping(params *SetTypingParams, authInfo runtime.ClientAuthInfoWriter) (*SetTypingOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSetTypingParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "setTyping",
		Method:             "PUT",
		PathPattern:        "/_matrix/client/unstable/rooms/{roomId}/typing/{userId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SetTypingReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SetTypingOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for setTyping: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
Sync synchronises the client s state and receive new messages

Synchronise the client's state with the latest state on the server.
Clients use this API when they first log in to get an initial snapshot
of the state on the server, and then continue to call this API to get
incremental deltas to the state, and to receive new messages.

*Note*: This endpoint supports lazy-loading. See `Filtering <#filtering>`_
for more information. Lazy-loading members is only supported on a ``StateFilter``
for this endpoint. When lazy-loading is enabled, servers MUST include the
syncing user's own membership event when they join a room, or when the
full state of rooms is requested, to aid discovering the user's avatar &
displayname.

Like other members, the user's own membership event is eligible
for being considered redundant by the server. When a sync is ``limited``,
the server MUST return membership events for events in the gap
(between ``since`` and the start of the returned timeline), regardless
as to whether or not they are redundant.  This ensures that joins/leaves
and profile changes which occur during the gap are not lost.
*/
func (a *Client) Sync(params *SyncParams, authInfo runtime.ClientAuthInfoWriter) (*SyncOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSyncParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "sync",
		Method:             "GET",
		PathPattern:        "/_matrix/client/unstable/sync",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SyncReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SyncOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for sync: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
