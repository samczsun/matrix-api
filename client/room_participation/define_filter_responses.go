// Code generated by go-swagger; DO NOT EDIT.

package room_participation

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"fmt"
	"io"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"

	strfmt "github.com/go-openapi/strfmt"
)

// DefineFilterReader is a Reader for the DefineFilter structure.
type DefineFilterReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *DefineFilterReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewDefineFilterOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil

	default:
		return nil, runtime.NewAPIError("unknown error", response, response.Code())
	}
}

// NewDefineFilterOK creates a DefineFilterOK with default headers values
func NewDefineFilterOK() *DefineFilterOK {
	return &DefineFilterOK{}
}

/*DefineFilterOK handles this case with default header values.

The filter was created.
*/
type DefineFilterOK struct {
	Payload *DefineFilterOKBody
}

func (o *DefineFilterOK) Error() string {
	return fmt.Sprintf("[POST /_matrix/client/unstable/user/{userId}/filter][%d] defineFilterOK  %+v", 200, o.Payload)
}

func (o *DefineFilterOK) GetPayload() *DefineFilterOKBody {
	return o.Payload
}

func (o *DefineFilterOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(DefineFilterOKBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*DefineFilterBody define filter body
swagger:model DefineFilterBody
*/
type DefineFilterBody struct {

	// The user account data that isn't associated with rooms to include.
	AccountData struct {

		// The maximum number of events to return.
		Limit int64 `json:"limit,omitempty"`

		// A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the ``'senders'`` filter.
		NotSenders []string `json:"not_senders"`

		// A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the ``'types'`` filter. A '*' can be used as a wildcard to match any sequence of characters.
		NotTypes []string `json:"not_types"`

		// A list of senders IDs to include. If this list is absent then all senders are included.
		Senders []string `json:"senders"`

		// A list of event types to include. If this list is absent then all event types are included. A ``'*'`` can be used as a wildcard to match any sequence of characters.
		Types []string `json:"types"`
	} `json:"account_data,omitempty"`

	// List of event fields to include. If this list is absent then all fields are included. The entries may include '.' characters to indicate sub-fields. So ['content.body'] will include the 'body' field of the 'content' object. A literal '.' character in a field name may be escaped using a '\\'. A server may include more fields than were requested.
	EventFields []string `json:"event_fields"`

	// The format to use for events. 'client' will return the events in a format suitable for clients. 'federation' will return the raw event as received over federation. The default is 'client'.
	// Enum: [client federation]
	EventFormat string `json:"event_format,omitempty"`

	// The presence updates to include.
	Presence struct {

		// The maximum number of events to return.
		Limit int64 `json:"limit,omitempty"`

		// A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the ``'senders'`` filter.
		NotSenders []string `json:"not_senders"`

		// A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the ``'types'`` filter. A '*' can be used as a wildcard to match any sequence of characters.
		NotTypes []string `json:"not_types"`

		// A list of senders IDs to include. If this list is absent then all senders are included.
		Senders []string `json:"senders"`

		// A list of event types to include. If this list is absent then all event types are included. A ``'*'`` can be used as a wildcard to match any sequence of characters.
		Types []string `json:"types"`
	} `json:"presence,omitempty"`

	// room
	Room *DefineFilterParamsBodyAO0Room `json:"room,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (o *DefineFilterBody) UnmarshalJSON(raw []byte) error {
	// DefineFilterParamsBodyAO0
	var dataDefineFilterParamsBodyAO0 struct {
		AccountData struct {

			// The maximum number of events to return.
			Limit int64 `json:"limit,omitempty"`

			// A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the ``'senders'`` filter.
			NotSenders []string `json:"not_senders"`

			// A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the ``'types'`` filter. A '*' can be used as a wildcard to match any sequence of characters.
			NotTypes []string `json:"not_types"`

			// A list of senders IDs to include. If this list is absent then all senders are included.
			Senders []string `json:"senders"`

			// A list of event types to include. If this list is absent then all event types are included. A ``'*'`` can be used as a wildcard to match any sequence of characters.
			Types []string `json:"types"`
		} `json:"account_data,omitempty"`

		EventFields []string `json:"event_fields"`

		EventFormat string `json:"event_format,omitempty"`

		Presence struct {

			// The maximum number of events to return.
			Limit int64 `json:"limit,omitempty"`

			// A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the ``'senders'`` filter.
			NotSenders []string `json:"not_senders"`

			// A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the ``'types'`` filter. A '*' can be used as a wildcard to match any sequence of characters.
			NotTypes []string `json:"not_types"`

			// A list of senders IDs to include. If this list is absent then all senders are included.
			Senders []string `json:"senders"`

			// A list of event types to include. If this list is absent then all event types are included. A ``'*'`` can be used as a wildcard to match any sequence of characters.
			Types []string `json:"types"`
		} `json:"presence,omitempty"`

		Room *DefineFilterParamsBodyAO0Room `json:"room,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataDefineFilterParamsBodyAO0); err != nil {
		return err
	}

	o.AccountData = dataDefineFilterParamsBodyAO0.AccountData

	o.EventFields = dataDefineFilterParamsBodyAO0.EventFields

	o.EventFormat = dataDefineFilterParamsBodyAO0.EventFormat

	o.Presence = dataDefineFilterParamsBodyAO0.Presence

	o.Room = dataDefineFilterParamsBodyAO0.Room

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (o DefineFilterBody) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 1)

	var dataDefineFilterParamsBodyAO0 struct {
		AccountData struct {

			// The maximum number of events to return.
			Limit int64 `json:"limit,omitempty"`

			// A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the ``'senders'`` filter.
			NotSenders []string `json:"not_senders"`

			// A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the ``'types'`` filter. A '*' can be used as a wildcard to match any sequence of characters.
			NotTypes []string `json:"not_types"`

			// A list of senders IDs to include. If this list is absent then all senders are included.
			Senders []string `json:"senders"`

			// A list of event types to include. If this list is absent then all event types are included. A ``'*'`` can be used as a wildcard to match any sequence of characters.
			Types []string `json:"types"`
		} `json:"account_data,omitempty"`

		EventFields []string `json:"event_fields"`

		EventFormat string `json:"event_format,omitempty"`

		Presence struct {

			// The maximum number of events to return.
			Limit int64 `json:"limit,omitempty"`

			// A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the ``'senders'`` filter.
			NotSenders []string `json:"not_senders"`

			// A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the ``'types'`` filter. A '*' can be used as a wildcard to match any sequence of characters.
			NotTypes []string `json:"not_types"`

			// A list of senders IDs to include. If this list is absent then all senders are included.
			Senders []string `json:"senders"`

			// A list of event types to include. If this list is absent then all event types are included. A ``'*'`` can be used as a wildcard to match any sequence of characters.
			Types []string `json:"types"`
		} `json:"presence,omitempty"`

		Room *DefineFilterParamsBodyAO0Room `json:"room,omitempty"`
	}

	dataDefineFilterParamsBodyAO0.AccountData = o.AccountData

	dataDefineFilterParamsBodyAO0.EventFields = o.EventFields

	dataDefineFilterParamsBodyAO0.EventFormat = o.EventFormat

	dataDefineFilterParamsBodyAO0.Presence = o.Presence

	dataDefineFilterParamsBodyAO0.Room = o.Room

	jsonDataDefineFilterParamsBodyAO0, errDefineFilterParamsBodyAO0 := swag.WriteJSON(dataDefineFilterParamsBodyAO0)
	if errDefineFilterParamsBodyAO0 != nil {
		return nil, errDefineFilterParamsBodyAO0
	}
	_parts = append(_parts, jsonDataDefineFilterParamsBodyAO0)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this define filter body
func (o *DefineFilterBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccountData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEventFormat(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePresence(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRoom(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *DefineFilterBody) validateAccountData(formats strfmt.Registry) error {

	if swag.IsZero(o.AccountData) { // not required
		return nil
	}

	return nil
}

var defineFilterBodyTypeEventFormatPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["client","federation"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		defineFilterBodyTypeEventFormatPropEnum = append(defineFilterBodyTypeEventFormatPropEnum, v)
	}
}

// property enum
func (o *DefineFilterBody) validateEventFormatEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, defineFilterBodyTypeEventFormatPropEnum); err != nil {
		return err
	}
	return nil
}

func (o *DefineFilterBody) validateEventFormat(formats strfmt.Registry) error {

	if swag.IsZero(o.EventFormat) { // not required
		return nil
	}

	// value enum
	if err := o.validateEventFormatEnum("filter"+"."+"event_format", "body", o.EventFormat); err != nil {
		return err
	}

	return nil
}

func (o *DefineFilterBody) validatePresence(formats strfmt.Registry) error {

	if swag.IsZero(o.Presence) { // not required
		return nil
	}

	return nil
}

func (o *DefineFilterBody) validateRoom(formats strfmt.Registry) error {

	if swag.IsZero(o.Room) { // not required
		return nil
	}

	if o.Room != nil {
		if err := o.Room.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("filter" + "." + "room")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *DefineFilterBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *DefineFilterBody) UnmarshalBinary(b []byte) error {
	var res DefineFilterBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*DefineFilterOKBody define filter o k body
swagger:model DefineFilterOKBody
*/
type DefineFilterOKBody struct {

	// The ID of the filter that was created. Cannot start
	// with a ``{`` as this character is used to determine
	// if the filter provided is inline JSON or a previously
	// declared filter by homeservers on some APIs.
	// Required: true
	FilterID *string `json:"filter_id"`
}

// Validate validates this define filter o k body
func (o *DefineFilterOKBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateFilterID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *DefineFilterOKBody) validateFilterID(formats strfmt.Registry) error {

	if err := validate.Required("defineFilterOK"+"."+"filter_id", "body", o.FilterID); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *DefineFilterOKBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *DefineFilterOKBody) UnmarshalBinary(b []byte) error {
	var res DefineFilterOKBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*DefineFilterParamsBodyAO0Room RoomFilter
//
// Filters to be applied to room data.
swagger:model DefineFilterParamsBodyAO0Room
*/
type DefineFilterParamsBodyAO0Room struct {

	// The per user account data to include for rooms.
	AccountData struct {
		DefineFilterParamsBodyAO0RoomAccountDataAllOf0
	} `json:"account_data,omitempty"`

	// The events that aren't recorded in the room history, e.g. typing and receipts, to include for rooms.
	Ephemeral struct {
		DefineFilterParamsBodyAO0RoomEphemeralAllOf0
	} `json:"ephemeral,omitempty"`

	// Include rooms that the user has left in the sync, default false
	IncludeLeave bool `json:"include_leave,omitempty"`

	// A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the ``'rooms'`` filter. This filter is applied before the filters in ``ephemeral``, ``state``, ``timeline`` or ``account_data``
	NotRooms []string `json:"not_rooms"`

	// A list of room IDs to include. If this list is absent then all rooms are included. This filter is applied before the filters in ``ephemeral``, ``state``, ``timeline`` or ``account_data``
	Rooms []string `json:"rooms"`

	// StateFilter
	//
	// The state events to include for rooms.
	State struct {
		DefineFilterParamsBodyAO0RoomStateAllOf0
	} `json:"state,omitempty"`

	// The message and state update events to include for rooms.
	Timeline struct {
		DefineFilterParamsBodyAO0RoomTimelineAllOf0
	} `json:"timeline,omitempty"`
}

// Validate validates this define filter params body a o0 room
func (o *DefineFilterParamsBodyAO0Room) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccountData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEphemeral(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTimeline(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *DefineFilterParamsBodyAO0Room) validateAccountData(formats strfmt.Registry) error {

	if swag.IsZero(o.AccountData) { // not required
		return nil
	}

	return nil
}

func (o *DefineFilterParamsBodyAO0Room) validateEphemeral(formats strfmt.Registry) error {

	if swag.IsZero(o.Ephemeral) { // not required
		return nil
	}

	return nil
}

func (o *DefineFilterParamsBodyAO0Room) validateState(formats strfmt.Registry) error {

	if swag.IsZero(o.State) { // not required
		return nil
	}

	return nil
}

func (o *DefineFilterParamsBodyAO0Room) validateTimeline(formats strfmt.Registry) error {

	if swag.IsZero(o.Timeline) { // not required
		return nil
	}

	return nil
}

// MarshalBinary interface implementation
func (o *DefineFilterParamsBodyAO0Room) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *DefineFilterParamsBodyAO0Room) UnmarshalBinary(b []byte) error {
	var res DefineFilterParamsBodyAO0Room
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*DefineFilterParamsBodyAO0RoomAccountDataAllOf0 define filter params body a o0 room account data all of0
swagger:model DefineFilterParamsBodyAO0RoomAccountDataAllOf0
*/
type DefineFilterParamsBodyAO0RoomAccountDataAllOf0 struct {

	// The maximum number of events to return.
	Limit int64 `json:"limit,omitempty"`

	// A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the ``'senders'`` filter.
	NotSenders []string `json:"not_senders"`

	// A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the ``'types'`` filter. A '*' can be used as a wildcard to match any sequence of characters.
	NotTypes []string `json:"not_types"`

	// A list of senders IDs to include. If this list is absent then all senders are included.
	Senders []string `json:"senders"`

	// A list of event types to include. If this list is absent then all event types are included. A ``'*'`` can be used as a wildcard to match any sequence of characters.
	Types []string `json:"types"`

	// If ``true``, includes only events with a ``url`` key in their content. If ``false``, excludes those events. If omitted, ``url`` key is not considered for filtering.
	ContainsURL bool `json:"contains_url,omitempty"`

	// If ``true``, sends all membership events for all events, even if they have already
	// been sent to the client. Does not
	// apply unless ``lazy_load_members`` is ``true``. See
	// `Lazy-loading room members <#lazy-loading-room-members>`_
	// for more information. Defaults to ``false``.
	IncludeRedundantMembers bool `json:"include_redundant_members,omitempty"`

	// If ``true``, enables lazy-loading of membership events. See
	// `Lazy-loading room members <#lazy-loading-room-members>`_
	// for more information. Defaults to ``false``.
	LazyLoadMembers bool `json:"lazy_load_members,omitempty"`

	// A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the ``'rooms'`` filter.
	NotRooms []string `json:"not_rooms"`

	// A list of room IDs to include. If this list is absent then all rooms are included.
	Rooms []string `json:"rooms"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (o *DefineFilterParamsBodyAO0RoomAccountDataAllOf0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Limit int64 `json:"limit,omitempty"`

		NotSenders []string `json:"not_senders"`

		NotTypes []string `json:"not_types"`

		Senders []string `json:"senders"`

		Types []string `json:"types"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	o.Limit = dataAO0.Limit

	o.NotSenders = dataAO0.NotSenders

	o.NotTypes = dataAO0.NotTypes

	o.Senders = dataAO0.Senders

	o.Types = dataAO0.Types

	// AO1
	var dataAO1 struct {
		ContainsURL bool `json:"contains_url,omitempty"`

		IncludeRedundantMembers bool `json:"include_redundant_members,omitempty"`

		LazyLoadMembers bool `json:"lazy_load_members,omitempty"`

		NotRooms []string `json:"not_rooms"`

		Rooms []string `json:"rooms"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	o.ContainsURL = dataAO1.ContainsURL

	o.IncludeRedundantMembers = dataAO1.IncludeRedundantMembers

	o.LazyLoadMembers = dataAO1.LazyLoadMembers

	o.NotRooms = dataAO1.NotRooms

	o.Rooms = dataAO1.Rooms

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (o DefineFilterParamsBodyAO0RoomAccountDataAllOf0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Limit int64 `json:"limit,omitempty"`

		NotSenders []string `json:"not_senders"`

		NotTypes []string `json:"not_types"`

		Senders []string `json:"senders"`

		Types []string `json:"types"`
	}

	dataAO0.Limit = o.Limit

	dataAO0.NotSenders = o.NotSenders

	dataAO0.NotTypes = o.NotTypes

	dataAO0.Senders = o.Senders

	dataAO0.Types = o.Types

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		ContainsURL bool `json:"contains_url,omitempty"`

		IncludeRedundantMembers bool `json:"include_redundant_members,omitempty"`

		LazyLoadMembers bool `json:"lazy_load_members,omitempty"`

		NotRooms []string `json:"not_rooms"`

		Rooms []string `json:"rooms"`
	}

	dataAO1.ContainsURL = o.ContainsURL

	dataAO1.IncludeRedundantMembers = o.IncludeRedundantMembers

	dataAO1.LazyLoadMembers = o.LazyLoadMembers

	dataAO1.NotRooms = o.NotRooms

	dataAO1.Rooms = o.Rooms

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this define filter params body a o0 room account data all of0
func (o *DefineFilterParamsBodyAO0RoomAccountDataAllOf0) Validate(formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (o *DefineFilterParamsBodyAO0RoomAccountDataAllOf0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *DefineFilterParamsBodyAO0RoomAccountDataAllOf0) UnmarshalBinary(b []byte) error {
	var res DefineFilterParamsBodyAO0RoomAccountDataAllOf0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*DefineFilterParamsBodyAO0RoomEphemeralAllOf0 define filter params body a o0 room ephemeral all of0
swagger:model DefineFilterParamsBodyAO0RoomEphemeralAllOf0
*/
type DefineFilterParamsBodyAO0RoomEphemeralAllOf0 struct {

	// The maximum number of events to return.
	Limit int64 `json:"limit,omitempty"`

	// A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the ``'senders'`` filter.
	NotSenders []string `json:"not_senders"`

	// A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the ``'types'`` filter. A '*' can be used as a wildcard to match any sequence of characters.
	NotTypes []string `json:"not_types"`

	// A list of senders IDs to include. If this list is absent then all senders are included.
	Senders []string `json:"senders"`

	// A list of event types to include. If this list is absent then all event types are included. A ``'*'`` can be used as a wildcard to match any sequence of characters.
	Types []string `json:"types"`

	// If ``true``, includes only events with a ``url`` key in their content. If ``false``, excludes those events. If omitted, ``url`` key is not considered for filtering.
	ContainsURL bool `json:"contains_url,omitempty"`

	// If ``true``, sends all membership events for all events, even if they have already
	// been sent to the client. Does not
	// apply unless ``lazy_load_members`` is ``true``. See
	// `Lazy-loading room members <#lazy-loading-room-members>`_
	// for more information. Defaults to ``false``.
	IncludeRedundantMembers bool `json:"include_redundant_members,omitempty"`

	// If ``true``, enables lazy-loading of membership events. See
	// `Lazy-loading room members <#lazy-loading-room-members>`_
	// for more information. Defaults to ``false``.
	LazyLoadMembers bool `json:"lazy_load_members,omitempty"`

	// A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the ``'rooms'`` filter.
	NotRooms []string `json:"not_rooms"`

	// A list of room IDs to include. If this list is absent then all rooms are included.
	Rooms []string `json:"rooms"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (o *DefineFilterParamsBodyAO0RoomEphemeralAllOf0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Limit int64 `json:"limit,omitempty"`

		NotSenders []string `json:"not_senders"`

		NotTypes []string `json:"not_types"`

		Senders []string `json:"senders"`

		Types []string `json:"types"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	o.Limit = dataAO0.Limit

	o.NotSenders = dataAO0.NotSenders

	o.NotTypes = dataAO0.NotTypes

	o.Senders = dataAO0.Senders

	o.Types = dataAO0.Types

	// AO1
	var dataAO1 struct {
		ContainsURL bool `json:"contains_url,omitempty"`

		IncludeRedundantMembers bool `json:"include_redundant_members,omitempty"`

		LazyLoadMembers bool `json:"lazy_load_members,omitempty"`

		NotRooms []string `json:"not_rooms"`

		Rooms []string `json:"rooms"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	o.ContainsURL = dataAO1.ContainsURL

	o.IncludeRedundantMembers = dataAO1.IncludeRedundantMembers

	o.LazyLoadMembers = dataAO1.LazyLoadMembers

	o.NotRooms = dataAO1.NotRooms

	o.Rooms = dataAO1.Rooms

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (o DefineFilterParamsBodyAO0RoomEphemeralAllOf0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Limit int64 `json:"limit,omitempty"`

		NotSenders []string `json:"not_senders"`

		NotTypes []string `json:"not_types"`

		Senders []string `json:"senders"`

		Types []string `json:"types"`
	}

	dataAO0.Limit = o.Limit

	dataAO0.NotSenders = o.NotSenders

	dataAO0.NotTypes = o.NotTypes

	dataAO0.Senders = o.Senders

	dataAO0.Types = o.Types

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		ContainsURL bool `json:"contains_url,omitempty"`

		IncludeRedundantMembers bool `json:"include_redundant_members,omitempty"`

		LazyLoadMembers bool `json:"lazy_load_members,omitempty"`

		NotRooms []string `json:"not_rooms"`

		Rooms []string `json:"rooms"`
	}

	dataAO1.ContainsURL = o.ContainsURL

	dataAO1.IncludeRedundantMembers = o.IncludeRedundantMembers

	dataAO1.LazyLoadMembers = o.LazyLoadMembers

	dataAO1.NotRooms = o.NotRooms

	dataAO1.Rooms = o.Rooms

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this define filter params body a o0 room ephemeral all of0
func (o *DefineFilterParamsBodyAO0RoomEphemeralAllOf0) Validate(formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (o *DefineFilterParamsBodyAO0RoomEphemeralAllOf0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *DefineFilterParamsBodyAO0RoomEphemeralAllOf0) UnmarshalBinary(b []byte) error {
	var res DefineFilterParamsBodyAO0RoomEphemeralAllOf0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*DefineFilterParamsBodyAO0RoomStateAllOf0 define filter params body a o0 room state all of0
swagger:model DefineFilterParamsBodyAO0RoomStateAllOf0
*/
type DefineFilterParamsBodyAO0RoomStateAllOf0 struct {

	// The maximum number of events to return.
	Limit int64 `json:"limit,omitempty"`

	// A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the ``'senders'`` filter.
	NotSenders []string `json:"not_senders"`

	// A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the ``'types'`` filter. A '*' can be used as a wildcard to match any sequence of characters.
	NotTypes []string `json:"not_types"`

	// A list of senders IDs to include. If this list is absent then all senders are included.
	Senders []string `json:"senders"`

	// A list of event types to include. If this list is absent then all event types are included. A ``'*'`` can be used as a wildcard to match any sequence of characters.
	Types []string `json:"types"`

	// If ``true``, includes only events with a ``url`` key in their content. If ``false``, excludes those events. If omitted, ``url`` key is not considered for filtering.
	ContainsURL bool `json:"contains_url,omitempty"`

	// If ``true``, sends all membership events for all events, even if they have already
	// been sent to the client. Does not
	// apply unless ``lazy_load_members`` is ``true``. See
	// `Lazy-loading room members <#lazy-loading-room-members>`_
	// for more information. Defaults to ``false``.
	IncludeRedundantMembers bool `json:"include_redundant_members,omitempty"`

	// If ``true``, enables lazy-loading of membership events. See
	// `Lazy-loading room members <#lazy-loading-room-members>`_
	// for more information. Defaults to ``false``.
	LazyLoadMembers bool `json:"lazy_load_members,omitempty"`

	// A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the ``'rooms'`` filter.
	NotRooms []string `json:"not_rooms"`

	// A list of room IDs to include. If this list is absent then all rooms are included.
	Rooms []string `json:"rooms"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (o *DefineFilterParamsBodyAO0RoomStateAllOf0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Limit int64 `json:"limit,omitempty"`

		NotSenders []string `json:"not_senders"`

		NotTypes []string `json:"not_types"`

		Senders []string `json:"senders"`

		Types []string `json:"types"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	o.Limit = dataAO0.Limit

	o.NotSenders = dataAO0.NotSenders

	o.NotTypes = dataAO0.NotTypes

	o.Senders = dataAO0.Senders

	o.Types = dataAO0.Types

	// AO1
	var dataAO1 struct {
		ContainsURL bool `json:"contains_url,omitempty"`

		IncludeRedundantMembers bool `json:"include_redundant_members,omitempty"`

		LazyLoadMembers bool `json:"lazy_load_members,omitempty"`

		NotRooms []string `json:"not_rooms"`

		Rooms []string `json:"rooms"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	o.ContainsURL = dataAO1.ContainsURL

	o.IncludeRedundantMembers = dataAO1.IncludeRedundantMembers

	o.LazyLoadMembers = dataAO1.LazyLoadMembers

	o.NotRooms = dataAO1.NotRooms

	o.Rooms = dataAO1.Rooms

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (o DefineFilterParamsBodyAO0RoomStateAllOf0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Limit int64 `json:"limit,omitempty"`

		NotSenders []string `json:"not_senders"`

		NotTypes []string `json:"not_types"`

		Senders []string `json:"senders"`

		Types []string `json:"types"`
	}

	dataAO0.Limit = o.Limit

	dataAO0.NotSenders = o.NotSenders

	dataAO0.NotTypes = o.NotTypes

	dataAO0.Senders = o.Senders

	dataAO0.Types = o.Types

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		ContainsURL bool `json:"contains_url,omitempty"`

		IncludeRedundantMembers bool `json:"include_redundant_members,omitempty"`

		LazyLoadMembers bool `json:"lazy_load_members,omitempty"`

		NotRooms []string `json:"not_rooms"`

		Rooms []string `json:"rooms"`
	}

	dataAO1.ContainsURL = o.ContainsURL

	dataAO1.IncludeRedundantMembers = o.IncludeRedundantMembers

	dataAO1.LazyLoadMembers = o.LazyLoadMembers

	dataAO1.NotRooms = o.NotRooms

	dataAO1.Rooms = o.Rooms

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this define filter params body a o0 room state all of0
func (o *DefineFilterParamsBodyAO0RoomStateAllOf0) Validate(formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (o *DefineFilterParamsBodyAO0RoomStateAllOf0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *DefineFilterParamsBodyAO0RoomStateAllOf0) UnmarshalBinary(b []byte) error {
	var res DefineFilterParamsBodyAO0RoomStateAllOf0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*DefineFilterParamsBodyAO0RoomTimelineAllOf0 define filter params body a o0 room timeline all of0
swagger:model DefineFilterParamsBodyAO0RoomTimelineAllOf0
*/
type DefineFilterParamsBodyAO0RoomTimelineAllOf0 struct {

	// The maximum number of events to return.
	Limit int64 `json:"limit,omitempty"`

	// A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the ``'senders'`` filter.
	NotSenders []string `json:"not_senders"`

	// A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the ``'types'`` filter. A '*' can be used as a wildcard to match any sequence of characters.
	NotTypes []string `json:"not_types"`

	// A list of senders IDs to include. If this list is absent then all senders are included.
	Senders []string `json:"senders"`

	// A list of event types to include. If this list is absent then all event types are included. A ``'*'`` can be used as a wildcard to match any sequence of characters.
	Types []string `json:"types"`

	// If ``true``, includes only events with a ``url`` key in their content. If ``false``, excludes those events. If omitted, ``url`` key is not considered for filtering.
	ContainsURL bool `json:"contains_url,omitempty"`

	// If ``true``, sends all membership events for all events, even if they have already
	// been sent to the client. Does not
	// apply unless ``lazy_load_members`` is ``true``. See
	// `Lazy-loading room members <#lazy-loading-room-members>`_
	// for more information. Defaults to ``false``.
	IncludeRedundantMembers bool `json:"include_redundant_members,omitempty"`

	// If ``true``, enables lazy-loading of membership events. See
	// `Lazy-loading room members <#lazy-loading-room-members>`_
	// for more information. Defaults to ``false``.
	LazyLoadMembers bool `json:"lazy_load_members,omitempty"`

	// A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the ``'rooms'`` filter.
	NotRooms []string `json:"not_rooms"`

	// A list of room IDs to include. If this list is absent then all rooms are included.
	Rooms []string `json:"rooms"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (o *DefineFilterParamsBodyAO0RoomTimelineAllOf0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Limit int64 `json:"limit,omitempty"`

		NotSenders []string `json:"not_senders"`

		NotTypes []string `json:"not_types"`

		Senders []string `json:"senders"`

		Types []string `json:"types"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	o.Limit = dataAO0.Limit

	o.NotSenders = dataAO0.NotSenders

	o.NotTypes = dataAO0.NotTypes

	o.Senders = dataAO0.Senders

	o.Types = dataAO0.Types

	// AO1
	var dataAO1 struct {
		ContainsURL bool `json:"contains_url,omitempty"`

		IncludeRedundantMembers bool `json:"include_redundant_members,omitempty"`

		LazyLoadMembers bool `json:"lazy_load_members,omitempty"`

		NotRooms []string `json:"not_rooms"`

		Rooms []string `json:"rooms"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	o.ContainsURL = dataAO1.ContainsURL

	o.IncludeRedundantMembers = dataAO1.IncludeRedundantMembers

	o.LazyLoadMembers = dataAO1.LazyLoadMembers

	o.NotRooms = dataAO1.NotRooms

	o.Rooms = dataAO1.Rooms

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (o DefineFilterParamsBodyAO0RoomTimelineAllOf0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Limit int64 `json:"limit,omitempty"`

		NotSenders []string `json:"not_senders"`

		NotTypes []string `json:"not_types"`

		Senders []string `json:"senders"`

		Types []string `json:"types"`
	}

	dataAO0.Limit = o.Limit

	dataAO0.NotSenders = o.NotSenders

	dataAO0.NotTypes = o.NotTypes

	dataAO0.Senders = o.Senders

	dataAO0.Types = o.Types

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		ContainsURL bool `json:"contains_url,omitempty"`

		IncludeRedundantMembers bool `json:"include_redundant_members,omitempty"`

		LazyLoadMembers bool `json:"lazy_load_members,omitempty"`

		NotRooms []string `json:"not_rooms"`

		Rooms []string `json:"rooms"`
	}

	dataAO1.ContainsURL = o.ContainsURL

	dataAO1.IncludeRedundantMembers = o.IncludeRedundantMembers

	dataAO1.LazyLoadMembers = o.LazyLoadMembers

	dataAO1.NotRooms = o.NotRooms

	dataAO1.Rooms = o.Rooms

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this define filter params body a o0 room timeline all of0
func (o *DefineFilterParamsBodyAO0RoomTimelineAllOf0) Validate(formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (o *DefineFilterParamsBodyAO0RoomTimelineAllOf0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *DefineFilterParamsBodyAO0RoomTimelineAllOf0) UnmarshalBinary(b []byte) error {
	var res DefineFilterParamsBodyAO0RoomTimelineAllOf0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
