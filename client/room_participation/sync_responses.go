// Code generated by go-swagger; DO NOT EDIT.

package room_participation

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"

	strfmt "github.com/go-openapi/strfmt"
)

// SyncReader is a Reader for the Sync structure.
type SyncReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *SyncReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewSyncOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil

	default:
		return nil, runtime.NewAPIError("unknown error", response, response.Code())
	}
}

// NewSyncOK creates a SyncOK with default headers values
func NewSyncOK() *SyncOK {
	return &SyncOK{}
}

/*SyncOK handles this case with default header values.

The initial snapshot or delta for the client to use to update their state.
*/
type SyncOK struct {
	Payload *SyncOKBody
}

func (o *SyncOK) Error() string {
	return fmt.Sprintf("[GET /_matrix/client/unstable/sync][%d] syncOK  %+v", 200, o.Payload)
}

func (o *SyncOK) GetPayload() *SyncOKBody {
	return o.Payload
}

func (o *SyncOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(SyncOKBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*EventsItems0 events items0
swagger:model EventsItems0
*/
type EventsItems0 struct {

	// The fields in this object will vary depending on the type of event. When interacting with the REST API, this is the HTTP body.
	// Required: true
	Content interface{} `json:"content"`

	// The type of event. This SHOULD be namespaced similar to Java package naming conventions e.g. 'com.example.subdomain.event.type'
	// Required: true
	Type *string `json:"type"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (o *EventsItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Content interface{} `json:"content"`

		Type *string `json:"type"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	o.Content = dataAO0.Content

	o.Type = dataAO0.Type

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (o EventsItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 1)

	var dataAO0 struct {
		Content interface{} `json:"content"`

		Type *string `json:"type"`
	}

	dataAO0.Content = o.Content

	dataAO0.Type = o.Type

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this events items0
func (o *EventsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateContent(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *EventsItems0) validateContent(formats strfmt.Registry) error {

	if err := validate.Required("content", "body", o.Content); err != nil {
		return err
	}

	return nil
}

func (o *EventsItems0) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", o.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *EventsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *EventsItems0) UnmarshalBinary(b []byte) error {
	var res EventsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*SyncOKBody sync o k body
swagger:model SyncOKBody
*/
type SyncOKBody struct {

	// Account Data
	//
	// The global private data created by this user.
	AccountData struct {

		// List of events.
		Events []*EventsItems0 `json:"events"`
	} `json:"account_data,omitempty"`

	// DeviceLists
	//
	// Information on end-to-end device updates, as specified in
	// |device_lists_sync|_.
	DeviceLists interface{} `json:"device_lists,omitempty"`

	// One-time keys count
	//
	// Information on end-to-end encryption keys, as specified
	// in |device_lists_sync|_.
	DeviceOneTimeKeysCount map[string]int64 `json:"device_one_time_keys_count,omitempty"`

	// The batch token to supply in the ``since`` param of the next
	// ``/sync`` request.
	// Required: true
	NextBatch *string `json:"next_batch"`

	// Presence
	//
	// The updates to the presence status of other users.
	Presence struct {

		// List of events.
		Events []*EventsItems0 `json:"events"`
	} `json:"presence,omitempty"`

	// rooms
	Rooms *SyncOKBodyRooms `json:"rooms,omitempty"`

	// ToDevice
	//
	// Information on the send-to-device messages for the client
	// device, as defined in |send_to_device_sync|_.
	ToDevice interface{} `json:"to_device,omitempty"`
}

// Validate validates this sync o k body
func (o *SyncOKBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccountData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNextBatch(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePresence(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRooms(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *SyncOKBody) validateAccountData(formats strfmt.Registry) error {

	if swag.IsZero(o.AccountData) { // not required
		return nil
	}

	for i := 0; i < len(o.AccountData.Events); i++ {
		if swag.IsZero(o.AccountData.Events[i]) { // not required
			continue
		}

		if o.AccountData.Events[i] != nil {
			if err := o.AccountData.Events[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("syncOK" + "." + "account_data" + "." + "events" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *SyncOKBody) validateNextBatch(formats strfmt.Registry) error {

	if err := validate.Required("syncOK"+"."+"next_batch", "body", o.NextBatch); err != nil {
		return err
	}

	return nil
}

func (o *SyncOKBody) validatePresence(formats strfmt.Registry) error {

	if swag.IsZero(o.Presence) { // not required
		return nil
	}

	for i := 0; i < len(o.Presence.Events); i++ {
		if swag.IsZero(o.Presence.Events[i]) { // not required
			continue
		}

		if o.Presence.Events[i] != nil {
			if err := o.Presence.Events[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("syncOK" + "." + "presence" + "." + "events" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *SyncOKBody) validateRooms(formats strfmt.Registry) error {

	if swag.IsZero(o.Rooms) { // not required
		return nil
	}

	if o.Rooms != nil {
		if err := o.Rooms.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("syncOK" + "." + "rooms")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *SyncOKBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *SyncOKBody) UnmarshalBinary(b []byte) error {
	var res SyncOKBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*SyncOKBodyRooms Rooms
//
// Updates to rooms.
swagger:model SyncOKBodyRooms
*/
type SyncOKBodyRooms struct {

	// Invited Rooms
	//
	// The rooms that the user has been invited to.
	Invite map[string]SyncOKBodyRoomsInviteAnon `json:"invite,omitempty"`

	// Joined Rooms
	//
	// The rooms that the user has joined.
	Join map[string]SyncOKBodyRoomsJoinAnon `json:"join,omitempty"`

	// Left rooms
	//
	// The rooms that the user has left or been banned from.
	Leave map[string]SyncOKBodyRoomsLeaveAnon `json:"leave,omitempty"`
}

// Validate validates this sync o k body rooms
func (o *SyncOKBodyRooms) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateInvite(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateJoin(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLeave(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *SyncOKBodyRooms) validateInvite(formats strfmt.Registry) error {

	if swag.IsZero(o.Invite) { // not required
		return nil
	}

	for k := range o.Invite {

		if swag.IsZero(o.Invite[k]) { // not required
			continue
		}
		if val, ok := o.Invite[k]; ok {
			if err := val.Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (o *SyncOKBodyRooms) validateJoin(formats strfmt.Registry) error {

	if swag.IsZero(o.Join) { // not required
		return nil
	}

	for k := range o.Join {

		if swag.IsZero(o.Join[k]) { // not required
			continue
		}
		if val, ok := o.Join[k]; ok {
			if err := val.Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (o *SyncOKBodyRooms) validateLeave(formats strfmt.Registry) error {

	if swag.IsZero(o.Leave) { // not required
		return nil
	}

	for k := range o.Leave {

		if swag.IsZero(o.Leave[k]) { // not required
			continue
		}
		if val, ok := o.Leave[k]; ok {
			if err := val.Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *SyncOKBodyRooms) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *SyncOKBodyRooms) UnmarshalBinary(b []byte) error {
	var res SyncOKBodyRooms
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*SyncOKBodyRoomsInviteAnon Invited Room
swagger:model SyncOKBodyRoomsInviteAnon
*/
type SyncOKBodyRoomsInviteAnon struct {

	// invite state
	InviteState *SyncOKBodyRoomsInviteAnonInviteState `json:"invite_state,omitempty"`
}

// Validate validates this sync o k body rooms invite anon
func (o *SyncOKBodyRoomsInviteAnon) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateInviteState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *SyncOKBodyRoomsInviteAnon) validateInviteState(formats strfmt.Registry) error {

	if swag.IsZero(o.InviteState) { // not required
		return nil
	}

	if o.InviteState != nil {
		if err := o.InviteState.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("invite_state")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *SyncOKBodyRoomsInviteAnon) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *SyncOKBodyRoomsInviteAnon) UnmarshalBinary(b []byte) error {
	var res SyncOKBodyRoomsInviteAnon
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*SyncOKBodyRoomsInviteAnonInviteState InviteState
//
// The state of a room that the user has been invited
// to. These state events may only have the ``sender``,
// ``type``, ``state_key`` and ``content`` keys
// present. These events do not replace any state that
// the client already has for the room, for example if
// the client has archived the room. Instead the
// client should keep two separate copies of the
// state: the one from the ``invite_state`` and one
// from the archived ``state``. If the client joins
// the room then the current state will be given as a
// delta against the archived ``state`` not the
// ``invite_state``.
swagger:model SyncOKBodyRoomsInviteAnonInviteState
*/
type SyncOKBodyRoomsInviteAnonInviteState struct {

	// The StrippedState events that form the invite state.
	Events []*SyncOKBodyRoomsInviteAnonInviteStateEventsItems0 `json:"events"`
}

// Validate validates this sync o k body rooms invite anon invite state
func (o *SyncOKBodyRoomsInviteAnonInviteState) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateEvents(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *SyncOKBodyRoomsInviteAnonInviteState) validateEvents(formats strfmt.Registry) error {

	if swag.IsZero(o.Events) { // not required
		return nil
	}

	for i := 0; i < len(o.Events); i++ {
		if swag.IsZero(o.Events[i]) { // not required
			continue
		}

		if o.Events[i] != nil {
			if err := o.Events[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("invite_state" + "." + "events" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *SyncOKBodyRoomsInviteAnonInviteState) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *SyncOKBodyRoomsInviteAnonInviteState) UnmarshalBinary(b []byte) error {
	var res SyncOKBodyRoomsInviteAnonInviteState
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*SyncOKBodyRoomsInviteAnonInviteStateEventsItems0 StrippedState
//
// A stripped down state event, with only the ``type``, ``state_key``,
// ``sender``, and ``content`` keys.
swagger:model SyncOKBodyRoomsInviteAnonInviteStateEventsItems0
*/
type SyncOKBodyRoomsInviteAnonInviteStateEventsItems0 struct {

	// EventContent
	//
	// The ``content`` for the event.
	// Required: true
	Content interface{} `json:"content"`

	// The ``sender`` for the event.
	// Required: true
	Sender *string `json:"sender"`

	// The ``state_key`` for the event.
	// Required: true
	StateKey *string `json:"state_key"`

	// The ``type`` for the event.
	// Required: true
	Type *string `json:"type"`
}

// Validate validates this sync o k body rooms invite anon invite state events items0
func (o *SyncOKBodyRoomsInviteAnonInviteStateEventsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateContent(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSender(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStateKey(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *SyncOKBodyRoomsInviteAnonInviteStateEventsItems0) validateContent(formats strfmt.Registry) error {

	if err := validate.Required("content", "body", o.Content); err != nil {
		return err
	}

	return nil
}

func (o *SyncOKBodyRoomsInviteAnonInviteStateEventsItems0) validateSender(formats strfmt.Registry) error {

	if err := validate.Required("sender", "body", o.Sender); err != nil {
		return err
	}

	return nil
}

func (o *SyncOKBodyRoomsInviteAnonInviteStateEventsItems0) validateStateKey(formats strfmt.Registry) error {

	if err := validate.Required("state_key", "body", o.StateKey); err != nil {
		return err
	}

	return nil
}

func (o *SyncOKBodyRoomsInviteAnonInviteStateEventsItems0) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", o.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *SyncOKBodyRoomsInviteAnonInviteStateEventsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *SyncOKBodyRoomsInviteAnonInviteStateEventsItems0) UnmarshalBinary(b []byte) error {
	var res SyncOKBodyRoomsInviteAnonInviteStateEventsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*SyncOKBodyRoomsJoinAnon Joined Room
swagger:model SyncOKBodyRoomsJoinAnon
*/
type SyncOKBodyRoomsJoinAnon struct {

	// Account Data
	//
	// The private data that this user has attached to
	// this room.
	AccountData struct {

		// List of events.
		Events []*SyncOKBodyRoomsJoinAnonEventsItems0 `json:"events"`
	} `json:"account_data,omitempty"`

	// Ephemeral
	//
	// The ephemeral events in the room that aren't
	// recorded in the timeline or state of the room.
	// e.g. typing.
	Ephemeral struct {

		// List of events.
		Events []*SyncOKBodyRoomsJoinAnonEventsItems0 `json:"events"`
	} `json:"ephemeral,omitempty"`

	// State
	//
	// Updates to the state, between the time indicated by
	// the ``since`` parameter, and the start of the
	// ``timeline`` (or all state up to the start of the
	// ``timeline``, if ``since`` is not given, or
	// ``full_state`` is true).
	//
	// N.B. state updates for ``m.room.member`` events will
	// be incomplete if ``lazy_load_members`` is enabled in
	// the ``/sync`` filter, and only return the member events
	// required to display the senders of the timeline events
	// in this response.
	State struct {

		// List of events.
		Events []*SyncOKBodyRoomsJoinAnonEventsItems0 `json:"events"`
	} `json:"state,omitempty"`

	// summary
	Summary *SyncOKBodyRoomsJoinAnonSummary `json:"summary,omitempty"`

	// Timeline
	//
	// The timeline of messages and state changes in the
	// room.
	Timeline struct {
		SyncOKBodyRoomsJoinAnonTimelineAllOf0
	} `json:"timeline,omitempty"`

	// unread notifications
	UnreadNotifications *SyncOKBodyRoomsJoinAnonUnreadNotifications `json:"unread_notifications,omitempty"`
}

// Validate validates this sync o k body rooms join anon
func (o *SyncOKBodyRoomsJoinAnon) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccountData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEphemeral(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSummary(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTimeline(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUnreadNotifications(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *SyncOKBodyRoomsJoinAnon) validateAccountData(formats strfmt.Registry) error {

	if swag.IsZero(o.AccountData) { // not required
		return nil
	}

	for i := 0; i < len(o.AccountData.Events); i++ {
		if swag.IsZero(o.AccountData.Events[i]) { // not required
			continue
		}

		if o.AccountData.Events[i] != nil {
			if err := o.AccountData.Events[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("account_data" + "." + "events" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *SyncOKBodyRoomsJoinAnon) validateEphemeral(formats strfmt.Registry) error {

	if swag.IsZero(o.Ephemeral) { // not required
		return nil
	}

	for i := 0; i < len(o.Ephemeral.Events); i++ {
		if swag.IsZero(o.Ephemeral.Events[i]) { // not required
			continue
		}

		if o.Ephemeral.Events[i] != nil {
			if err := o.Ephemeral.Events[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ephemeral" + "." + "events" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *SyncOKBodyRoomsJoinAnon) validateState(formats strfmt.Registry) error {

	if swag.IsZero(o.State) { // not required
		return nil
	}

	for i := 0; i < len(o.State.Events); i++ {
		if swag.IsZero(o.State.Events[i]) { // not required
			continue
		}

		if o.State.Events[i] != nil {
			if err := o.State.Events[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("state" + "." + "events" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *SyncOKBodyRoomsJoinAnon) validateSummary(formats strfmt.Registry) error {

	if swag.IsZero(o.Summary) { // not required
		return nil
	}

	if o.Summary != nil {
		if err := o.Summary.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("summary")
			}
			return err
		}
	}

	return nil
}

func (o *SyncOKBodyRoomsJoinAnon) validateTimeline(formats strfmt.Registry) error {

	if swag.IsZero(o.Timeline) { // not required
		return nil
	}

	return nil
}

func (o *SyncOKBodyRoomsJoinAnon) validateUnreadNotifications(formats strfmt.Registry) error {

	if swag.IsZero(o.UnreadNotifications) { // not required
		return nil
	}

	if o.UnreadNotifications != nil {
		if err := o.UnreadNotifications.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("unread_notifications")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *SyncOKBodyRoomsJoinAnon) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *SyncOKBodyRoomsJoinAnon) UnmarshalBinary(b []byte) error {
	var res SyncOKBodyRoomsJoinAnon
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*SyncOKBodyRoomsJoinAnonEventsItems0 sync o k body rooms join anon events items0
swagger:model SyncOKBodyRoomsJoinAnonEventsItems0
*/
type SyncOKBodyRoomsJoinAnonEventsItems0 struct {
	SyncOKBodyRoomsJoinAnonEventsItems0AllOf0
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (o *SyncOKBodyRoomsJoinAnonEventsItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 SyncOKBodyRoomsJoinAnonEventsItems0AllOf0
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	o.SyncOKBodyRoomsJoinAnonEventsItems0AllOf0 = aO0

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (o SyncOKBodyRoomsJoinAnonEventsItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 1)

	aO0, err := swag.WriteJSON(o.SyncOKBodyRoomsJoinAnonEventsItems0AllOf0)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this sync o k body rooms join anon events items0
func (o *SyncOKBodyRoomsJoinAnonEventsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with SyncOKBodyRoomsJoinAnonEventsItems0AllOf0
	if err := o.SyncOKBodyRoomsJoinAnonEventsItems0AllOf0.Validate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (o *SyncOKBodyRoomsJoinAnonEventsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *SyncOKBodyRoomsJoinAnonEventsItems0) UnmarshalBinary(b []byte) error {
	var res SyncOKBodyRoomsJoinAnonEventsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*SyncOKBodyRoomsJoinAnonEventsItems0AllOf0 State Event
//
// In addition to the Room Event fields, State Events have the following additional fields.
swagger:model SyncOKBodyRoomsJoinAnonEventsItems0AllOf0
*/
type SyncOKBodyRoomsJoinAnonEventsItems0AllOf0 struct {
	SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0

	// EventContent
	//
	// Optional. The previous ``content`` for this event. If there is no previous content, this key will be missing.
	PrevContent interface{} `json:"prev_content,omitempty"`

	// A unique key which defines the overwriting semantics for this piece of room state. This value is often a zero-length string. The presence of this key makes this event a State Event.
	// State keys starting with an ``@`` are reserved for referencing user IDs, such as room members. With the exception of a few events, state events set with a given user's ID as the state key MUST only be set by that user.
	// Required: true
	StateKey *string `json:"state_key"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (o *SyncOKBodyRoomsJoinAnonEventsItems0AllOf0) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	o.SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0 = aO0

	// now for regular properties
	var propsSyncOKBodyRoomsJoinAnonEventsItems0AllOf0 struct {
		PrevContent interface{} `json:"prev_content,omitempty"`

		StateKey *string `json:"state_key"`
	}
	if err := swag.ReadJSON(raw, &propsSyncOKBodyRoomsJoinAnonEventsItems0AllOf0); err != nil {
		return err
	}
	o.PrevContent = propsSyncOKBodyRoomsJoinAnonEventsItems0AllOf0.PrevContent

	o.StateKey = propsSyncOKBodyRoomsJoinAnonEventsItems0AllOf0.StateKey

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (o SyncOKBodyRoomsJoinAnonEventsItems0AllOf0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 1)

	aO0, err := swag.WriteJSON(o.SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	// now for regular properties
	var propsSyncOKBodyRoomsJoinAnonEventsItems0AllOf0 struct {
		PrevContent interface{} `json:"prev_content,omitempty"`

		StateKey *string `json:"state_key"`
	}
	propsSyncOKBodyRoomsJoinAnonEventsItems0AllOf0.PrevContent = o.PrevContent

	propsSyncOKBodyRoomsJoinAnonEventsItems0AllOf0.StateKey = o.StateKey

	jsonDataPropsSyncOKBodyRoomsJoinAnonEventsItems0AllOf0, errSyncOKBodyRoomsJoinAnonEventsItems0AllOf0 := swag.WriteJSON(propsSyncOKBodyRoomsJoinAnonEventsItems0AllOf0)
	if errSyncOKBodyRoomsJoinAnonEventsItems0AllOf0 != nil {
		return nil, errSyncOKBodyRoomsJoinAnonEventsItems0AllOf0
	}
	_parts = append(_parts, jsonDataPropsSyncOKBodyRoomsJoinAnonEventsItems0AllOf0)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this sync o k body rooms join anon events items0 all of0
func (o *SyncOKBodyRoomsJoinAnonEventsItems0AllOf0) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0
	if err := o.SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStateKey(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *SyncOKBodyRoomsJoinAnonEventsItems0AllOf0) validateStateKey(formats strfmt.Registry) error {

	if err := validate.Required("state_key", "body", o.StateKey); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *SyncOKBodyRoomsJoinAnonEventsItems0AllOf0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *SyncOKBodyRoomsJoinAnonEventsItems0AllOf0) UnmarshalBinary(b []byte) error {
	var res SyncOKBodyRoomsJoinAnonEventsItems0AllOf0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0 Room Event
//
// In addition to the Event fields, Room Events have the following additional fields.
swagger:model SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0
*/
type SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0 struct {

	// The fields in this object will vary depending on the type of event. When interacting with the REST API, this is the HTTP body.
	// Required: true
	Content interface{} `json:"content"`

	// The type of event. This SHOULD be namespaced similar to Java package naming conventions e.g. 'com.example.subdomain.event.type'
	// Required: true
	Type *string `json:"type"`

	// The globally unique event identifier.
	// Required: true
	EventID *string `json:"event_id"`

	// Timestamp in milliseconds on originating homeserver when this event was sent.
	// Required: true
	OriginServerTs *int64 `json:"origin_server_ts"`

	// Contains the fully-qualified ID of the user who sent this event.
	// Required: true
	Sender *string `json:"sender"`

	// unsigned
	Unsigned *SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0Unsigned `json:"unsigned,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (o *SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Content interface{} `json:"content"`

		Type *string `json:"type"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	o.Content = dataAO0.Content

	o.Type = dataAO0.Type

	// now for regular properties
	var propsSyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0 struct {
		EventID *string `json:"event_id"`

		OriginServerTs *int64 `json:"origin_server_ts"`

		Sender *string `json:"sender"`

		Unsigned *SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0Unsigned `json:"unsigned,omitempty"`
	}
	if err := swag.ReadJSON(raw, &propsSyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0); err != nil {
		return err
	}
	o.EventID = propsSyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0.EventID

	o.OriginServerTs = propsSyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0.OriginServerTs

	o.Sender = propsSyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0.Sender

	o.Unsigned = propsSyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0.Unsigned

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (o SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 1)

	var dataAO0 struct {
		Content interface{} `json:"content"`

		Type *string `json:"type"`
	}

	dataAO0.Content = o.Content

	dataAO0.Type = o.Type

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	// now for regular properties
	var propsSyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0 struct {
		EventID *string `json:"event_id"`

		OriginServerTs *int64 `json:"origin_server_ts"`

		Sender *string `json:"sender"`

		Unsigned *SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0Unsigned `json:"unsigned,omitempty"`
	}
	propsSyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0.EventID = o.EventID

	propsSyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0.OriginServerTs = o.OriginServerTs

	propsSyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0.Sender = o.Sender

	propsSyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0.Unsigned = o.Unsigned

	jsonDataPropsSyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0, errSyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0 := swag.WriteJSON(propsSyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0)
	if errSyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0 != nil {
		return nil, errSyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0
	}
	_parts = append(_parts, jsonDataPropsSyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this sync o k body rooms join anon events items0 all of0 all of0
func (o *SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateContent(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEventID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginServerTs(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSender(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUnsigned(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0) validateEventID(formats strfmt.Registry) error {

	if err := validate.Required("event_id", "body", o.EventID); err != nil {
		return err
	}

	return nil
}

func (o *SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0) validateOriginServerTs(formats strfmt.Registry) error {

	if err := validate.Required("origin_server_ts", "body", o.OriginServerTs); err != nil {
		return err
	}

	return nil
}

func (o *SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0) validateSender(formats strfmt.Registry) error {

	if err := validate.Required("sender", "body", o.Sender); err != nil {
		return err
	}

	return nil
}

func (o *SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0) validateUnsigned(formats strfmt.Registry) error {

	if swag.IsZero(o.Unsigned) { // not required
		return nil
	}

	if o.Unsigned != nil {
		if err := o.Unsigned.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("unsigned")
			}
			return err
		}
	}

	return nil
}

func (o *SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0) validateContent(formats strfmt.Registry) error {

	if err := validate.Required("content", "body", o.Content); err != nil {
		return err
	}

	return nil
}

func (o *SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", o.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0) UnmarshalBinary(b []byte) error {
	var res SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0Unsigned UnsignedData
//
// Contains optional extra information about the event.
swagger:model SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0Unsigned
*/
type SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0Unsigned struct {

	// The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is.
	Age int64 `json:"age,omitempty"`

	// Event
	//
	// Optional. The event that redacted this event, if any.
	RedactedBecause interface{} `json:"redacted_because,omitempty"`

	// The client-supplied transaction ID, if the client being given the event is the same one which sent it.
	TransactionID string `json:"transaction_id,omitempty"`
}

// Validate validates this sync o k body rooms join anon events items0 all of0 all of0 unsigned
func (o *SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0Unsigned) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0Unsigned) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0Unsigned) UnmarshalBinary(b []byte) error {
	var res SyncOKBodyRoomsJoinAnonEventsItems0AllOf0AllOf0Unsigned
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*SyncOKBodyRoomsJoinAnonSummary RoomSummary
//
// Information about the room which clients may need to
// correctly render it to users.
swagger:model SyncOKBodyRoomsJoinAnonSummary
*/
type SyncOKBodyRoomsJoinAnonSummary struct {

	// The users which can be used to generate a room name
	// if the room does not have one. Required if the room's
	// ``m.room.name`` or ``m.room.canonical_alias`` state events
	// are unset or empty.
	//
	// This should be the first 5 members of the room, ordered
	// by stream ordering, which are joined or invited. The
	// list must never include the client's own user ID. When
	// no joined or invited members are available, this should
	// consist of the banned and left users. More than 5 members
	// may be provided, however less than 5 should only be provided
	// when there are less than 5 members to represent.
	//
	// When lazy-loading room members is enabled, the membership
	// events for the heroes MUST be included in the ``state``,
	// unless they are redundant. When the list of users changes,
	// the server notifies the client by sending a fresh list of
	// heroes. If there are no changes since the last sync, this
	// field may be omitted.
	MHeroes []string `json:"m.heroes"`

	// The number of users with ``membership`` of ``invite``.
	// If this field has not changed since the last sync, it
	// may be omitted. Required otherwise.
	MInvitedMemberCount int64 `json:"m.invited_member_count,omitempty"`

	// The number of users with ``membership`` of ``join``,
	// including the client's own user ID. If this field has
	// not changed since the last sync, it may be omitted.
	// Required otherwise.
	MJoinedMemberCount int64 `json:"m.joined_member_count,omitempty"`
}

// Validate validates this sync o k body rooms join anon summary
func (o *SyncOKBodyRoomsJoinAnonSummary) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *SyncOKBodyRoomsJoinAnonSummary) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *SyncOKBodyRoomsJoinAnonSummary) UnmarshalBinary(b []byte) error {
	var res SyncOKBodyRoomsJoinAnonSummary
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*SyncOKBodyRoomsJoinAnonTimelineAllOf0 sync o k body rooms join anon timeline all of0
swagger:model SyncOKBodyRoomsJoinAnonTimelineAllOf0
*/
type SyncOKBodyRoomsJoinAnonTimelineAllOf0 struct {

	// List of events.
	Events []*SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0 `json:"events"`

	// True if the number of events returned was limited by the ``limit`` on the filter.
	Limited bool `json:"limited,omitempty"`

	// A token that can be supplied to the ``from`` parameter of the rooms/{roomId}/messages endpoint.
	PrevBatch string `json:"prev_batch,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (o *SyncOKBodyRoomsJoinAnonTimelineAllOf0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Events []*SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0 `json:"events"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	o.Events = dataAO0.Events

	// now for regular properties
	var propsSyncOKBodyRoomsJoinAnonTimelineAllOf0 struct {
		Limited bool `json:"limited,omitempty"`

		PrevBatch string `json:"prev_batch,omitempty"`
	}
	if err := swag.ReadJSON(raw, &propsSyncOKBodyRoomsJoinAnonTimelineAllOf0); err != nil {
		return err
	}
	o.Limited = propsSyncOKBodyRoomsJoinAnonTimelineAllOf0.Limited

	o.PrevBatch = propsSyncOKBodyRoomsJoinAnonTimelineAllOf0.PrevBatch

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (o SyncOKBodyRoomsJoinAnonTimelineAllOf0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 1)

	var dataAO0 struct {
		Events []*SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0 `json:"events"`
	}

	dataAO0.Events = o.Events

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	// now for regular properties
	var propsSyncOKBodyRoomsJoinAnonTimelineAllOf0 struct {
		Limited bool `json:"limited,omitempty"`

		PrevBatch string `json:"prev_batch,omitempty"`
	}
	propsSyncOKBodyRoomsJoinAnonTimelineAllOf0.Limited = o.Limited

	propsSyncOKBodyRoomsJoinAnonTimelineAllOf0.PrevBatch = o.PrevBatch

	jsonDataPropsSyncOKBodyRoomsJoinAnonTimelineAllOf0, errSyncOKBodyRoomsJoinAnonTimelineAllOf0 := swag.WriteJSON(propsSyncOKBodyRoomsJoinAnonTimelineAllOf0)
	if errSyncOKBodyRoomsJoinAnonTimelineAllOf0 != nil {
		return nil, errSyncOKBodyRoomsJoinAnonTimelineAllOf0
	}
	_parts = append(_parts, jsonDataPropsSyncOKBodyRoomsJoinAnonTimelineAllOf0)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this sync o k body rooms join anon timeline all of0
func (o *SyncOKBodyRoomsJoinAnonTimelineAllOf0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateEvents(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *SyncOKBodyRoomsJoinAnonTimelineAllOf0) validateEvents(formats strfmt.Registry) error {

	if swag.IsZero(o.Events) { // not required
		return nil
	}

	for i := 0; i < len(o.Events); i++ {
		if swag.IsZero(o.Events[i]) { // not required
			continue
		}

		if o.Events[i] != nil {
			if err := o.Events[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("events" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *SyncOKBodyRoomsJoinAnonTimelineAllOf0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *SyncOKBodyRoomsJoinAnonTimelineAllOf0) UnmarshalBinary(b []byte) error {
	var res SyncOKBodyRoomsJoinAnonTimelineAllOf0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0 sync o k body rooms join anon timeline all of0 events items0
swagger:model SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0
*/
type SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0 struct {
	SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (o *SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	o.SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0 = aO0

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (o SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 1)

	aO0, err := swag.WriteJSON(o.SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this sync o k body rooms join anon timeline all of0 events items0
func (o *SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0
	if err := o.SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0.Validate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (o *SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0) UnmarshalBinary(b []byte) error {
	var res SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0 Room Event
//
// In addition to the Event fields, Room Events have the following additional fields.
swagger:model SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0
*/
type SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0 struct {

	// The fields in this object will vary depending on the type of event. When interacting with the REST API, this is the HTTP body.
	// Required: true
	Content interface{} `json:"content"`

	// The type of event. This SHOULD be namespaced similar to Java package naming conventions e.g. 'com.example.subdomain.event.type'
	// Required: true
	Type *string `json:"type"`

	// The globally unique event identifier.
	// Required: true
	EventID *string `json:"event_id"`

	// Timestamp in milliseconds on originating homeserver when this event was sent.
	// Required: true
	OriginServerTs *int64 `json:"origin_server_ts"`

	// Contains the fully-qualified ID of the user who sent this event.
	// Required: true
	Sender *string `json:"sender"`

	// unsigned
	Unsigned *SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0Unsigned `json:"unsigned,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (o *SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Content interface{} `json:"content"`

		Type *string `json:"type"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	o.Content = dataAO0.Content

	o.Type = dataAO0.Type

	// now for regular properties
	var propsSyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0 struct {
		EventID *string `json:"event_id"`

		OriginServerTs *int64 `json:"origin_server_ts"`

		Sender *string `json:"sender"`

		Unsigned *SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0Unsigned `json:"unsigned,omitempty"`
	}
	if err := swag.ReadJSON(raw, &propsSyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0); err != nil {
		return err
	}
	o.EventID = propsSyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0.EventID

	o.OriginServerTs = propsSyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0.OriginServerTs

	o.Sender = propsSyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0.Sender

	o.Unsigned = propsSyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0.Unsigned

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (o SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 1)

	var dataAO0 struct {
		Content interface{} `json:"content"`

		Type *string `json:"type"`
	}

	dataAO0.Content = o.Content

	dataAO0.Type = o.Type

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	// now for regular properties
	var propsSyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0 struct {
		EventID *string `json:"event_id"`

		OriginServerTs *int64 `json:"origin_server_ts"`

		Sender *string `json:"sender"`

		Unsigned *SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0Unsigned `json:"unsigned,omitempty"`
	}
	propsSyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0.EventID = o.EventID

	propsSyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0.OriginServerTs = o.OriginServerTs

	propsSyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0.Sender = o.Sender

	propsSyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0.Unsigned = o.Unsigned

	jsonDataPropsSyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0, errSyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0 := swag.WriteJSON(propsSyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0)
	if errSyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0 != nil {
		return nil, errSyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0
	}
	_parts = append(_parts, jsonDataPropsSyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this sync o k body rooms join anon timeline all of0 events items0 all of0
func (o *SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateContent(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEventID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginServerTs(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSender(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUnsigned(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0) validateEventID(formats strfmt.Registry) error {

	if err := validate.Required("event_id", "body", o.EventID); err != nil {
		return err
	}

	return nil
}

func (o *SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0) validateOriginServerTs(formats strfmt.Registry) error {

	if err := validate.Required("origin_server_ts", "body", o.OriginServerTs); err != nil {
		return err
	}

	return nil
}

func (o *SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0) validateSender(formats strfmt.Registry) error {

	if err := validate.Required("sender", "body", o.Sender); err != nil {
		return err
	}

	return nil
}

func (o *SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0) validateUnsigned(formats strfmt.Registry) error {

	if swag.IsZero(o.Unsigned) { // not required
		return nil
	}

	if o.Unsigned != nil {
		if err := o.Unsigned.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("unsigned")
			}
			return err
		}
	}

	return nil
}

func (o *SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0) validateContent(formats strfmt.Registry) error {

	if err := validate.Required("content", "body", o.Content); err != nil {
		return err
	}

	return nil
}

func (o *SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", o.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0) UnmarshalBinary(b []byte) error {
	var res SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0Unsigned UnsignedData
//
// Contains optional extra information about the event.
swagger:model SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0Unsigned
*/
type SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0Unsigned struct {

	// The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is.
	Age int64 `json:"age,omitempty"`

	// Event
	//
	// Optional. The event that redacted this event, if any.
	RedactedBecause interface{} `json:"redacted_because,omitempty"`

	// The client-supplied transaction ID, if the client being given the event is the same one which sent it.
	TransactionID string `json:"transaction_id,omitempty"`
}

// Validate validates this sync o k body rooms join anon timeline all of0 events items0 all of0 unsigned
func (o *SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0Unsigned) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0Unsigned) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0Unsigned) UnmarshalBinary(b []byte) error {
	var res SyncOKBodyRoomsJoinAnonTimelineAllOf0EventsItems0AllOf0Unsigned
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*SyncOKBodyRoomsJoinAnonUnreadNotifications Unread Notification Counts
//
// Counts of unread notifications for this room. See the
// `Receiving notifications section <#receiving-notifications>`_
// for more information on how these are calculated.
swagger:model SyncOKBodyRoomsJoinAnonUnreadNotifications
*/
type SyncOKBodyRoomsJoinAnonUnreadNotifications struct {

	// Highlighted notification count
	//
	// The number of unread notifications for this room with the highlight flag set
	HighlightCount int64 `json:"highlight_count,omitempty"`

	// Total notification count
	//
	// The total number of unread notifications for this room
	NotificationCount int64 `json:"notification_count,omitempty"`
}

// Validate validates this sync o k body rooms join anon unread notifications
func (o *SyncOKBodyRoomsJoinAnonUnreadNotifications) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *SyncOKBodyRoomsJoinAnonUnreadNotifications) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *SyncOKBodyRoomsJoinAnonUnreadNotifications) UnmarshalBinary(b []byte) error {
	var res SyncOKBodyRoomsJoinAnonUnreadNotifications
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*SyncOKBodyRoomsLeaveAnon Left Room
swagger:model SyncOKBodyRoomsLeaveAnon
*/
type SyncOKBodyRoomsLeaveAnon struct {

	// Account Data
	//
	// The private data that this user has attached to
	// this room.
	AccountData struct {

		// List of events.
		Events []*SyncOKBodyRoomsLeaveAnonEventsItems0 `json:"events"`
	} `json:"account_data,omitempty"`

	// State
	//
	// The state updates for the room up to the start of the timeline.
	State struct {

		// List of events.
		Events []*SyncOKBodyRoomsLeaveAnonEventsItems0 `json:"events"`
	} `json:"state,omitempty"`

	// Timeline
	//
	// The timeline of messages and state changes in the
	// room up to the point when the user left.
	Timeline struct {
		SyncOKBodyRoomsLeaveAnonTimelineAllOf0
	} `json:"timeline,omitempty"`
}

// Validate validates this sync o k body rooms leave anon
func (o *SyncOKBodyRoomsLeaveAnon) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccountData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTimeline(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *SyncOKBodyRoomsLeaveAnon) validateAccountData(formats strfmt.Registry) error {

	if swag.IsZero(o.AccountData) { // not required
		return nil
	}

	for i := 0; i < len(o.AccountData.Events); i++ {
		if swag.IsZero(o.AccountData.Events[i]) { // not required
			continue
		}

		if o.AccountData.Events[i] != nil {
			if err := o.AccountData.Events[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("account_data" + "." + "events" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *SyncOKBodyRoomsLeaveAnon) validateState(formats strfmt.Registry) error {

	if swag.IsZero(o.State) { // not required
		return nil
	}

	for i := 0; i < len(o.State.Events); i++ {
		if swag.IsZero(o.State.Events[i]) { // not required
			continue
		}

		if o.State.Events[i] != nil {
			if err := o.State.Events[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("state" + "." + "events" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *SyncOKBodyRoomsLeaveAnon) validateTimeline(formats strfmt.Registry) error {

	if swag.IsZero(o.Timeline) { // not required
		return nil
	}

	return nil
}

// MarshalBinary interface implementation
func (o *SyncOKBodyRoomsLeaveAnon) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *SyncOKBodyRoomsLeaveAnon) UnmarshalBinary(b []byte) error {
	var res SyncOKBodyRoomsLeaveAnon
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*SyncOKBodyRoomsLeaveAnonEventsItems0 sync o k body rooms leave anon events items0
swagger:model SyncOKBodyRoomsLeaveAnonEventsItems0
*/
type SyncOKBodyRoomsLeaveAnonEventsItems0 struct {
	SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (o *SyncOKBodyRoomsLeaveAnonEventsItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	o.SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0 = aO0

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (o SyncOKBodyRoomsLeaveAnonEventsItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 1)

	aO0, err := swag.WriteJSON(o.SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this sync o k body rooms leave anon events items0
func (o *SyncOKBodyRoomsLeaveAnonEventsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0
	if err := o.SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0.Validate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (o *SyncOKBodyRoomsLeaveAnonEventsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *SyncOKBodyRoomsLeaveAnonEventsItems0) UnmarshalBinary(b []byte) error {
	var res SyncOKBodyRoomsLeaveAnonEventsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0 State Event
//
// In addition to the Room Event fields, State Events have the following additional fields.
swagger:model SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0
*/
type SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0 struct {
	SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0

	// EventContent
	//
	// Optional. The previous ``content`` for this event. If there is no previous content, this key will be missing.
	PrevContent interface{} `json:"prev_content,omitempty"`

	// A unique key which defines the overwriting semantics for this piece of room state. This value is often a zero-length string. The presence of this key makes this event a State Event.
	// State keys starting with an ``@`` are reserved for referencing user IDs, such as room members. With the exception of a few events, state events set with a given user's ID as the state key MUST only be set by that user.
	// Required: true
	StateKey *string `json:"state_key"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (o *SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	o.SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0 = aO0

	// now for regular properties
	var propsSyncOKBodyRoomsLeaveAnonEventsItems0AllOf0 struct {
		PrevContent interface{} `json:"prev_content,omitempty"`

		StateKey *string `json:"state_key"`
	}
	if err := swag.ReadJSON(raw, &propsSyncOKBodyRoomsLeaveAnonEventsItems0AllOf0); err != nil {
		return err
	}
	o.PrevContent = propsSyncOKBodyRoomsLeaveAnonEventsItems0AllOf0.PrevContent

	o.StateKey = propsSyncOKBodyRoomsLeaveAnonEventsItems0AllOf0.StateKey

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (o SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 1)

	aO0, err := swag.WriteJSON(o.SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	// now for regular properties
	var propsSyncOKBodyRoomsLeaveAnonEventsItems0AllOf0 struct {
		PrevContent interface{} `json:"prev_content,omitempty"`

		StateKey *string `json:"state_key"`
	}
	propsSyncOKBodyRoomsLeaveAnonEventsItems0AllOf0.PrevContent = o.PrevContent

	propsSyncOKBodyRoomsLeaveAnonEventsItems0AllOf0.StateKey = o.StateKey

	jsonDataPropsSyncOKBodyRoomsLeaveAnonEventsItems0AllOf0, errSyncOKBodyRoomsLeaveAnonEventsItems0AllOf0 := swag.WriteJSON(propsSyncOKBodyRoomsLeaveAnonEventsItems0AllOf0)
	if errSyncOKBodyRoomsLeaveAnonEventsItems0AllOf0 != nil {
		return nil, errSyncOKBodyRoomsLeaveAnonEventsItems0AllOf0
	}
	_parts = append(_parts, jsonDataPropsSyncOKBodyRoomsLeaveAnonEventsItems0AllOf0)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this sync o k body rooms leave anon events items0 all of0
func (o *SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0
	if err := o.SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStateKey(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0) validateStateKey(formats strfmt.Registry) error {

	if err := validate.Required("state_key", "body", o.StateKey); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0) UnmarshalBinary(b []byte) error {
	var res SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0 Room Event
//
// In addition to the Event fields, Room Events have the following additional fields.
swagger:model SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0
*/
type SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0 struct {

	// The fields in this object will vary depending on the type of event. When interacting with the REST API, this is the HTTP body.
	// Required: true
	Content interface{} `json:"content"`

	// The type of event. This SHOULD be namespaced similar to Java package naming conventions e.g. 'com.example.subdomain.event.type'
	// Required: true
	Type *string `json:"type"`

	// The globally unique event identifier.
	// Required: true
	EventID *string `json:"event_id"`

	// Timestamp in milliseconds on originating homeserver when this event was sent.
	// Required: true
	OriginServerTs *int64 `json:"origin_server_ts"`

	// Contains the fully-qualified ID of the user who sent this event.
	// Required: true
	Sender *string `json:"sender"`

	// unsigned
	Unsigned *SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0Unsigned `json:"unsigned,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (o *SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Content interface{} `json:"content"`

		Type *string `json:"type"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	o.Content = dataAO0.Content

	o.Type = dataAO0.Type

	// now for regular properties
	var propsSyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0 struct {
		EventID *string `json:"event_id"`

		OriginServerTs *int64 `json:"origin_server_ts"`

		Sender *string `json:"sender"`

		Unsigned *SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0Unsigned `json:"unsigned,omitempty"`
	}
	if err := swag.ReadJSON(raw, &propsSyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0); err != nil {
		return err
	}
	o.EventID = propsSyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0.EventID

	o.OriginServerTs = propsSyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0.OriginServerTs

	o.Sender = propsSyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0.Sender

	o.Unsigned = propsSyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0.Unsigned

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (o SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 1)

	var dataAO0 struct {
		Content interface{} `json:"content"`

		Type *string `json:"type"`
	}

	dataAO0.Content = o.Content

	dataAO0.Type = o.Type

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	// now for regular properties
	var propsSyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0 struct {
		EventID *string `json:"event_id"`

		OriginServerTs *int64 `json:"origin_server_ts"`

		Sender *string `json:"sender"`

		Unsigned *SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0Unsigned `json:"unsigned,omitempty"`
	}
	propsSyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0.EventID = o.EventID

	propsSyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0.OriginServerTs = o.OriginServerTs

	propsSyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0.Sender = o.Sender

	propsSyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0.Unsigned = o.Unsigned

	jsonDataPropsSyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0, errSyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0 := swag.WriteJSON(propsSyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0)
	if errSyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0 != nil {
		return nil, errSyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0
	}
	_parts = append(_parts, jsonDataPropsSyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this sync o k body rooms leave anon events items0 all of0 all of0
func (o *SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateContent(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEventID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginServerTs(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSender(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUnsigned(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0) validateEventID(formats strfmt.Registry) error {

	if err := validate.Required("event_id", "body", o.EventID); err != nil {
		return err
	}

	return nil
}

func (o *SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0) validateOriginServerTs(formats strfmt.Registry) error {

	if err := validate.Required("origin_server_ts", "body", o.OriginServerTs); err != nil {
		return err
	}

	return nil
}

func (o *SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0) validateSender(formats strfmt.Registry) error {

	if err := validate.Required("sender", "body", o.Sender); err != nil {
		return err
	}

	return nil
}

func (o *SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0) validateUnsigned(formats strfmt.Registry) error {

	if swag.IsZero(o.Unsigned) { // not required
		return nil
	}

	if o.Unsigned != nil {
		if err := o.Unsigned.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("unsigned")
			}
			return err
		}
	}

	return nil
}

func (o *SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0) validateContent(formats strfmt.Registry) error {

	if err := validate.Required("content", "body", o.Content); err != nil {
		return err
	}

	return nil
}

func (o *SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", o.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0) UnmarshalBinary(b []byte) error {
	var res SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0Unsigned UnsignedData
//
// Contains optional extra information about the event.
swagger:model SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0Unsigned
*/
type SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0Unsigned struct {

	// The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is.
	Age int64 `json:"age,omitempty"`

	// Event
	//
	// Optional. The event that redacted this event, if any.
	RedactedBecause interface{} `json:"redacted_because,omitempty"`

	// The client-supplied transaction ID, if the client being given the event is the same one which sent it.
	TransactionID string `json:"transaction_id,omitempty"`
}

// Validate validates this sync o k body rooms leave anon events items0 all of0 all of0 unsigned
func (o *SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0Unsigned) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0Unsigned) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0Unsigned) UnmarshalBinary(b []byte) error {
	var res SyncOKBodyRoomsLeaveAnonEventsItems0AllOf0AllOf0Unsigned
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*SyncOKBodyRoomsLeaveAnonTimelineAllOf0 sync o k body rooms leave anon timeline all of0
swagger:model SyncOKBodyRoomsLeaveAnonTimelineAllOf0
*/
type SyncOKBodyRoomsLeaveAnonTimelineAllOf0 struct {

	// List of events.
	Events []*SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0 `json:"events"`

	// True if the number of events returned was limited by the ``limit`` on the filter.
	Limited bool `json:"limited,omitempty"`

	// A token that can be supplied to the ``from`` parameter of the rooms/{roomId}/messages endpoint.
	PrevBatch string `json:"prev_batch,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (o *SyncOKBodyRoomsLeaveAnonTimelineAllOf0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Events []*SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0 `json:"events"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	o.Events = dataAO0.Events

	// now for regular properties
	var propsSyncOKBodyRoomsLeaveAnonTimelineAllOf0 struct {
		Limited bool `json:"limited,omitempty"`

		PrevBatch string `json:"prev_batch,omitempty"`
	}
	if err := swag.ReadJSON(raw, &propsSyncOKBodyRoomsLeaveAnonTimelineAllOf0); err != nil {
		return err
	}
	o.Limited = propsSyncOKBodyRoomsLeaveAnonTimelineAllOf0.Limited

	o.PrevBatch = propsSyncOKBodyRoomsLeaveAnonTimelineAllOf0.PrevBatch

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (o SyncOKBodyRoomsLeaveAnonTimelineAllOf0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 1)

	var dataAO0 struct {
		Events []*SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0 `json:"events"`
	}

	dataAO0.Events = o.Events

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	// now for regular properties
	var propsSyncOKBodyRoomsLeaveAnonTimelineAllOf0 struct {
		Limited bool `json:"limited,omitempty"`

		PrevBatch string `json:"prev_batch,omitempty"`
	}
	propsSyncOKBodyRoomsLeaveAnonTimelineAllOf0.Limited = o.Limited

	propsSyncOKBodyRoomsLeaveAnonTimelineAllOf0.PrevBatch = o.PrevBatch

	jsonDataPropsSyncOKBodyRoomsLeaveAnonTimelineAllOf0, errSyncOKBodyRoomsLeaveAnonTimelineAllOf0 := swag.WriteJSON(propsSyncOKBodyRoomsLeaveAnonTimelineAllOf0)
	if errSyncOKBodyRoomsLeaveAnonTimelineAllOf0 != nil {
		return nil, errSyncOKBodyRoomsLeaveAnonTimelineAllOf0
	}
	_parts = append(_parts, jsonDataPropsSyncOKBodyRoomsLeaveAnonTimelineAllOf0)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this sync o k body rooms leave anon timeline all of0
func (o *SyncOKBodyRoomsLeaveAnonTimelineAllOf0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateEvents(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *SyncOKBodyRoomsLeaveAnonTimelineAllOf0) validateEvents(formats strfmt.Registry) error {

	if swag.IsZero(o.Events) { // not required
		return nil
	}

	for i := 0; i < len(o.Events); i++ {
		if swag.IsZero(o.Events[i]) { // not required
			continue
		}

		if o.Events[i] != nil {
			if err := o.Events[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("events" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *SyncOKBodyRoomsLeaveAnonTimelineAllOf0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *SyncOKBodyRoomsLeaveAnonTimelineAllOf0) UnmarshalBinary(b []byte) error {
	var res SyncOKBodyRoomsLeaveAnonTimelineAllOf0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0 sync o k body rooms leave anon timeline all of0 events items0
swagger:model SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0
*/
type SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0 struct {
	SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (o *SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	o.SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0 = aO0

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (o SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 1)

	aO0, err := swag.WriteJSON(o.SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this sync o k body rooms leave anon timeline all of0 events items0
func (o *SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0
	if err := o.SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0.Validate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (o *SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0) UnmarshalBinary(b []byte) error {
	var res SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0 Room Event
//
// In addition to the Event fields, Room Events have the following additional fields.
swagger:model SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0
*/
type SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0 struct {

	// The fields in this object will vary depending on the type of event. When interacting with the REST API, this is the HTTP body.
	// Required: true
	Content interface{} `json:"content"`

	// The type of event. This SHOULD be namespaced similar to Java package naming conventions e.g. 'com.example.subdomain.event.type'
	// Required: true
	Type *string `json:"type"`

	// The globally unique event identifier.
	// Required: true
	EventID *string `json:"event_id"`

	// Timestamp in milliseconds on originating homeserver when this event was sent.
	// Required: true
	OriginServerTs *int64 `json:"origin_server_ts"`

	// Contains the fully-qualified ID of the user who sent this event.
	// Required: true
	Sender *string `json:"sender"`

	// unsigned
	Unsigned *SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0Unsigned `json:"unsigned,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (o *SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Content interface{} `json:"content"`

		Type *string `json:"type"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	o.Content = dataAO0.Content

	o.Type = dataAO0.Type

	// now for regular properties
	var propsSyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0 struct {
		EventID *string `json:"event_id"`

		OriginServerTs *int64 `json:"origin_server_ts"`

		Sender *string `json:"sender"`

		Unsigned *SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0Unsigned `json:"unsigned,omitempty"`
	}
	if err := swag.ReadJSON(raw, &propsSyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0); err != nil {
		return err
	}
	o.EventID = propsSyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0.EventID

	o.OriginServerTs = propsSyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0.OriginServerTs

	o.Sender = propsSyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0.Sender

	o.Unsigned = propsSyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0.Unsigned

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (o SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 1)

	var dataAO0 struct {
		Content interface{} `json:"content"`

		Type *string `json:"type"`
	}

	dataAO0.Content = o.Content

	dataAO0.Type = o.Type

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	// now for regular properties
	var propsSyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0 struct {
		EventID *string `json:"event_id"`

		OriginServerTs *int64 `json:"origin_server_ts"`

		Sender *string `json:"sender"`

		Unsigned *SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0Unsigned `json:"unsigned,omitempty"`
	}
	propsSyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0.EventID = o.EventID

	propsSyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0.OriginServerTs = o.OriginServerTs

	propsSyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0.Sender = o.Sender

	propsSyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0.Unsigned = o.Unsigned

	jsonDataPropsSyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0, errSyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0 := swag.WriteJSON(propsSyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0)
	if errSyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0 != nil {
		return nil, errSyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0
	}
	_parts = append(_parts, jsonDataPropsSyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this sync o k body rooms leave anon timeline all of0 events items0 all of0
func (o *SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateContent(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEventID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginServerTs(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSender(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUnsigned(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0) validateEventID(formats strfmt.Registry) error {

	if err := validate.Required("event_id", "body", o.EventID); err != nil {
		return err
	}

	return nil
}

func (o *SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0) validateOriginServerTs(formats strfmt.Registry) error {

	if err := validate.Required("origin_server_ts", "body", o.OriginServerTs); err != nil {
		return err
	}

	return nil
}

func (o *SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0) validateSender(formats strfmt.Registry) error {

	if err := validate.Required("sender", "body", o.Sender); err != nil {
		return err
	}

	return nil
}

func (o *SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0) validateUnsigned(formats strfmt.Registry) error {

	if swag.IsZero(o.Unsigned) { // not required
		return nil
	}

	if o.Unsigned != nil {
		if err := o.Unsigned.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("unsigned")
			}
			return err
		}
	}

	return nil
}

func (o *SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0) validateContent(formats strfmt.Registry) error {

	if err := validate.Required("content", "body", o.Content); err != nil {
		return err
	}

	return nil
}

func (o *SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", o.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0) UnmarshalBinary(b []byte) error {
	var res SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0Unsigned UnsignedData
//
// Contains optional extra information about the event.
swagger:model SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0Unsigned
*/
type SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0Unsigned struct {

	// The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is.
	Age int64 `json:"age,omitempty"`

	// Event
	//
	// Optional. The event that redacted this event, if any.
	RedactedBecause interface{} `json:"redacted_because,omitempty"`

	// The client-supplied transaction ID, if the client being given the event is the same one which sent it.
	TransactionID string `json:"transaction_id,omitempty"`
}

// Validate validates this sync o k body rooms leave anon timeline all of0 events items0 all of0 unsigned
func (o *SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0Unsigned) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0Unsigned) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0Unsigned) UnmarshalBinary(b []byte) error {
	var res SyncOKBodyRoomsLeaveAnonTimelineAllOf0EventsItems0AllOf0Unsigned
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
