// Code generated by go-swagger; DO NOT EDIT.

package room_participation

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"fmt"
	"io"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"

	strfmt "github.com/go-openapi/strfmt"
)

// GetFilterReader is a Reader for the GetFilter structure.
type GetFilterReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *GetFilterReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewGetFilterOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 404:
		result := NewGetFilterNotFound()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result

	default:
		return nil, runtime.NewAPIError("unknown error", response, response.Code())
	}
}

// NewGetFilterOK creates a GetFilterOK with default headers values
func NewGetFilterOK() *GetFilterOK {
	return &GetFilterOK{}
}

/*GetFilterOK handles this case with default header values.

"The filter defintion"
*/
type GetFilterOK struct {
	Payload *GetFilterOKBody
}

func (o *GetFilterOK) Error() string {
	return fmt.Sprintf("[GET /_matrix/client/unstable/user/{userId}/filter/{filterId}][%d] getFilterOK  %+v", 200, o.Payload)
}

func (o *GetFilterOK) GetPayload() *GetFilterOKBody {
	return o.Payload
}

func (o *GetFilterOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(GetFilterOKBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewGetFilterNotFound creates a GetFilterNotFound with default headers values
func NewGetFilterNotFound() *GetFilterNotFound {
	return &GetFilterNotFound{}
}

/*GetFilterNotFound handles this case with default header values.

Unknown filter.
*/
type GetFilterNotFound struct {
}

func (o *GetFilterNotFound) Error() string {
	return fmt.Sprintf("[GET /_matrix/client/unstable/user/{userId}/filter/{filterId}][%d] getFilterNotFound ", 404)
}

func (o *GetFilterNotFound) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

/*GetFilterOKBody get filter o k body
swagger:model GetFilterOKBody
*/
type GetFilterOKBody struct {

	// The user account data that isn't associated with rooms to include.
	AccountData struct {

		// The maximum number of events to return.
		Limit int64 `json:"limit,omitempty"`

		// A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the ``'senders'`` filter.
		NotSenders []string `json:"not_senders"`

		// A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the ``'types'`` filter. A '*' can be used as a wildcard to match any sequence of characters.
		NotTypes []string `json:"not_types"`

		// A list of senders IDs to include. If this list is absent then all senders are included.
		Senders []string `json:"senders"`

		// A list of event types to include. If this list is absent then all event types are included. A ``'*'`` can be used as a wildcard to match any sequence of characters.
		Types []string `json:"types"`
	} `json:"account_data,omitempty"`

	// List of event fields to include. If this list is absent then all fields are included. The entries may include '.' characters to indicate sub-fields. So ['content.body'] will include the 'body' field of the 'content' object. A literal '.' character in a field name may be escaped using a '\\'. A server may include more fields than were requested.
	EventFields []string `json:"event_fields"`

	// The format to use for events. 'client' will return the events in a format suitable for clients. 'federation' will return the raw event as received over federation. The default is 'client'.
	// Enum: [client federation]
	EventFormat string `json:"event_format,omitempty"`

	// The presence updates to include.
	Presence struct {

		// The maximum number of events to return.
		Limit int64 `json:"limit,omitempty"`

		// A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the ``'senders'`` filter.
		NotSenders []string `json:"not_senders"`

		// A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the ``'types'`` filter. A '*' can be used as a wildcard to match any sequence of characters.
		NotTypes []string `json:"not_types"`

		// A list of senders IDs to include. If this list is absent then all senders are included.
		Senders []string `json:"senders"`

		// A list of event types to include. If this list is absent then all event types are included. A ``'*'`` can be used as a wildcard to match any sequence of characters.
		Types []string `json:"types"`
	} `json:"presence,omitempty"`

	// room
	Room *GetFilterOKBodyAO0Room `json:"room,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (o *GetFilterOKBody) UnmarshalJSON(raw []byte) error {
	// GetFilterOKBodyAO0
	var dataGetFilterOKBodyAO0 struct {
		AccountData struct {

			// The maximum number of events to return.
			Limit int64 `json:"limit,omitempty"`

			// A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the ``'senders'`` filter.
			NotSenders []string `json:"not_senders"`

			// A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the ``'types'`` filter. A '*' can be used as a wildcard to match any sequence of characters.
			NotTypes []string `json:"not_types"`

			// A list of senders IDs to include. If this list is absent then all senders are included.
			Senders []string `json:"senders"`

			// A list of event types to include. If this list is absent then all event types are included. A ``'*'`` can be used as a wildcard to match any sequence of characters.
			Types []string `json:"types"`
		} `json:"account_data,omitempty"`

		EventFields []string `json:"event_fields"`

		EventFormat string `json:"event_format,omitempty"`

		Presence struct {

			// The maximum number of events to return.
			Limit int64 `json:"limit,omitempty"`

			// A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the ``'senders'`` filter.
			NotSenders []string `json:"not_senders"`

			// A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the ``'types'`` filter. A '*' can be used as a wildcard to match any sequence of characters.
			NotTypes []string `json:"not_types"`

			// A list of senders IDs to include. If this list is absent then all senders are included.
			Senders []string `json:"senders"`

			// A list of event types to include. If this list is absent then all event types are included. A ``'*'`` can be used as a wildcard to match any sequence of characters.
			Types []string `json:"types"`
		} `json:"presence,omitempty"`

		Room *GetFilterOKBodyAO0Room `json:"room,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataGetFilterOKBodyAO0); err != nil {
		return err
	}

	o.AccountData = dataGetFilterOKBodyAO0.AccountData

	o.EventFields = dataGetFilterOKBodyAO0.EventFields

	o.EventFormat = dataGetFilterOKBodyAO0.EventFormat

	o.Presence = dataGetFilterOKBodyAO0.Presence

	o.Room = dataGetFilterOKBodyAO0.Room

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (o GetFilterOKBody) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 1)

	var dataGetFilterOKBodyAO0 struct {
		AccountData struct {

			// The maximum number of events to return.
			Limit int64 `json:"limit,omitempty"`

			// A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the ``'senders'`` filter.
			NotSenders []string `json:"not_senders"`

			// A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the ``'types'`` filter. A '*' can be used as a wildcard to match any sequence of characters.
			NotTypes []string `json:"not_types"`

			// A list of senders IDs to include. If this list is absent then all senders are included.
			Senders []string `json:"senders"`

			// A list of event types to include. If this list is absent then all event types are included. A ``'*'`` can be used as a wildcard to match any sequence of characters.
			Types []string `json:"types"`
		} `json:"account_data,omitempty"`

		EventFields []string `json:"event_fields"`

		EventFormat string `json:"event_format,omitempty"`

		Presence struct {

			// The maximum number of events to return.
			Limit int64 `json:"limit,omitempty"`

			// A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the ``'senders'`` filter.
			NotSenders []string `json:"not_senders"`

			// A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the ``'types'`` filter. A '*' can be used as a wildcard to match any sequence of characters.
			NotTypes []string `json:"not_types"`

			// A list of senders IDs to include. If this list is absent then all senders are included.
			Senders []string `json:"senders"`

			// A list of event types to include. If this list is absent then all event types are included. A ``'*'`` can be used as a wildcard to match any sequence of characters.
			Types []string `json:"types"`
		} `json:"presence,omitempty"`

		Room *GetFilterOKBodyAO0Room `json:"room,omitempty"`
	}

	dataGetFilterOKBodyAO0.AccountData = o.AccountData

	dataGetFilterOKBodyAO0.EventFields = o.EventFields

	dataGetFilterOKBodyAO0.EventFormat = o.EventFormat

	dataGetFilterOKBodyAO0.Presence = o.Presence

	dataGetFilterOKBodyAO0.Room = o.Room

	jsonDataGetFilterOKBodyAO0, errGetFilterOKBodyAO0 := swag.WriteJSON(dataGetFilterOKBodyAO0)
	if errGetFilterOKBodyAO0 != nil {
		return nil, errGetFilterOKBodyAO0
	}
	_parts = append(_parts, jsonDataGetFilterOKBodyAO0)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this get filter o k body
func (o *GetFilterOKBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccountData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEventFormat(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePresence(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRoom(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetFilterOKBody) validateAccountData(formats strfmt.Registry) error {

	if swag.IsZero(o.AccountData) { // not required
		return nil
	}

	return nil
}

var getFilterOKBodyTypeEventFormatPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["client","federation"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		getFilterOKBodyTypeEventFormatPropEnum = append(getFilterOKBodyTypeEventFormatPropEnum, v)
	}
}

// property enum
func (o *GetFilterOKBody) validateEventFormatEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, getFilterOKBodyTypeEventFormatPropEnum); err != nil {
		return err
	}
	return nil
}

func (o *GetFilterOKBody) validateEventFormat(formats strfmt.Registry) error {

	if swag.IsZero(o.EventFormat) { // not required
		return nil
	}

	// value enum
	if err := o.validateEventFormatEnum("getFilterOK"+"."+"event_format", "body", o.EventFormat); err != nil {
		return err
	}

	return nil
}

func (o *GetFilterOKBody) validatePresence(formats strfmt.Registry) error {

	if swag.IsZero(o.Presence) { // not required
		return nil
	}

	return nil
}

func (o *GetFilterOKBody) validateRoom(formats strfmt.Registry) error {

	if swag.IsZero(o.Room) { // not required
		return nil
	}

	if o.Room != nil {
		if err := o.Room.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getFilterOK" + "." + "room")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetFilterOKBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetFilterOKBody) UnmarshalBinary(b []byte) error {
	var res GetFilterOKBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetFilterOKBodyAO0Room RoomFilter
//
// Filters to be applied to room data.
swagger:model GetFilterOKBodyAO0Room
*/
type GetFilterOKBodyAO0Room struct {

	// The per user account data to include for rooms.
	AccountData struct {
		GetFilterOKBodyAO0RoomAccountDataAllOf0
	} `json:"account_data,omitempty"`

	// The events that aren't recorded in the room history, e.g. typing and receipts, to include for rooms.
	Ephemeral struct {
		GetFilterOKBodyAO0RoomEphemeralAllOf0
	} `json:"ephemeral,omitempty"`

	// Include rooms that the user has left in the sync, default false
	IncludeLeave bool `json:"include_leave,omitempty"`

	// A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the ``'rooms'`` filter. This filter is applied before the filters in ``ephemeral``, ``state``, ``timeline`` or ``account_data``
	NotRooms []string `json:"not_rooms"`

	// A list of room IDs to include. If this list is absent then all rooms are included. This filter is applied before the filters in ``ephemeral``, ``state``, ``timeline`` or ``account_data``
	Rooms []string `json:"rooms"`

	// StateFilter
	//
	// The state events to include for rooms.
	State struct {
		GetFilterOKBodyAO0RoomStateAllOf0
	} `json:"state,omitempty"`

	// The message and state update events to include for rooms.
	Timeline struct {
		GetFilterOKBodyAO0RoomTimelineAllOf0
	} `json:"timeline,omitempty"`
}

// Validate validates this get filter o k body a o0 room
func (o *GetFilterOKBodyAO0Room) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccountData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEphemeral(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTimeline(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetFilterOKBodyAO0Room) validateAccountData(formats strfmt.Registry) error {

	if swag.IsZero(o.AccountData) { // not required
		return nil
	}

	return nil
}

func (o *GetFilterOKBodyAO0Room) validateEphemeral(formats strfmt.Registry) error {

	if swag.IsZero(o.Ephemeral) { // not required
		return nil
	}

	return nil
}

func (o *GetFilterOKBodyAO0Room) validateState(formats strfmt.Registry) error {

	if swag.IsZero(o.State) { // not required
		return nil
	}

	return nil
}

func (o *GetFilterOKBodyAO0Room) validateTimeline(formats strfmt.Registry) error {

	if swag.IsZero(o.Timeline) { // not required
		return nil
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetFilterOKBodyAO0Room) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetFilterOKBodyAO0Room) UnmarshalBinary(b []byte) error {
	var res GetFilterOKBodyAO0Room
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetFilterOKBodyAO0RoomAccountDataAllOf0 get filter o k body a o0 room account data all of0
swagger:model GetFilterOKBodyAO0RoomAccountDataAllOf0
*/
type GetFilterOKBodyAO0RoomAccountDataAllOf0 struct {

	// The maximum number of events to return.
	Limit int64 `json:"limit,omitempty"`

	// A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the ``'senders'`` filter.
	NotSenders []string `json:"not_senders"`

	// A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the ``'types'`` filter. A '*' can be used as a wildcard to match any sequence of characters.
	NotTypes []string `json:"not_types"`

	// A list of senders IDs to include. If this list is absent then all senders are included.
	Senders []string `json:"senders"`

	// A list of event types to include. If this list is absent then all event types are included. A ``'*'`` can be used as a wildcard to match any sequence of characters.
	Types []string `json:"types"`

	// If ``true``, includes only events with a ``url`` key in their content. If ``false``, excludes those events. If omitted, ``url`` key is not considered for filtering.
	ContainsURL bool `json:"contains_url,omitempty"`

	// If ``true``, sends all membership events for all events, even if they have already
	// been sent to the client. Does not
	// apply unless ``lazy_load_members`` is ``true``. See
	// `Lazy-loading room members <#lazy-loading-room-members>`_
	// for more information. Defaults to ``false``.
	IncludeRedundantMembers bool `json:"include_redundant_members,omitempty"`

	// If ``true``, enables lazy-loading of membership events. See
	// `Lazy-loading room members <#lazy-loading-room-members>`_
	// for more information. Defaults to ``false``.
	LazyLoadMembers bool `json:"lazy_load_members,omitempty"`

	// A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the ``'rooms'`` filter.
	NotRooms []string `json:"not_rooms"`

	// A list of room IDs to include. If this list is absent then all rooms are included.
	Rooms []string `json:"rooms"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (o *GetFilterOKBodyAO0RoomAccountDataAllOf0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Limit int64 `json:"limit,omitempty"`

		NotSenders []string `json:"not_senders"`

		NotTypes []string `json:"not_types"`

		Senders []string `json:"senders"`

		Types []string `json:"types"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	o.Limit = dataAO0.Limit

	o.NotSenders = dataAO0.NotSenders

	o.NotTypes = dataAO0.NotTypes

	o.Senders = dataAO0.Senders

	o.Types = dataAO0.Types

	// AO1
	var dataAO1 struct {
		ContainsURL bool `json:"contains_url,omitempty"`

		IncludeRedundantMembers bool `json:"include_redundant_members,omitempty"`

		LazyLoadMembers bool `json:"lazy_load_members,omitempty"`

		NotRooms []string `json:"not_rooms"`

		Rooms []string `json:"rooms"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	o.ContainsURL = dataAO1.ContainsURL

	o.IncludeRedundantMembers = dataAO1.IncludeRedundantMembers

	o.LazyLoadMembers = dataAO1.LazyLoadMembers

	o.NotRooms = dataAO1.NotRooms

	o.Rooms = dataAO1.Rooms

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (o GetFilterOKBodyAO0RoomAccountDataAllOf0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Limit int64 `json:"limit,omitempty"`

		NotSenders []string `json:"not_senders"`

		NotTypes []string `json:"not_types"`

		Senders []string `json:"senders"`

		Types []string `json:"types"`
	}

	dataAO0.Limit = o.Limit

	dataAO0.NotSenders = o.NotSenders

	dataAO0.NotTypes = o.NotTypes

	dataAO0.Senders = o.Senders

	dataAO0.Types = o.Types

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		ContainsURL bool `json:"contains_url,omitempty"`

		IncludeRedundantMembers bool `json:"include_redundant_members,omitempty"`

		LazyLoadMembers bool `json:"lazy_load_members,omitempty"`

		NotRooms []string `json:"not_rooms"`

		Rooms []string `json:"rooms"`
	}

	dataAO1.ContainsURL = o.ContainsURL

	dataAO1.IncludeRedundantMembers = o.IncludeRedundantMembers

	dataAO1.LazyLoadMembers = o.LazyLoadMembers

	dataAO1.NotRooms = o.NotRooms

	dataAO1.Rooms = o.Rooms

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this get filter o k body a o0 room account data all of0
func (o *GetFilterOKBodyAO0RoomAccountDataAllOf0) Validate(formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (o *GetFilterOKBodyAO0RoomAccountDataAllOf0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetFilterOKBodyAO0RoomAccountDataAllOf0) UnmarshalBinary(b []byte) error {
	var res GetFilterOKBodyAO0RoomAccountDataAllOf0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetFilterOKBodyAO0RoomEphemeralAllOf0 get filter o k body a o0 room ephemeral all of0
swagger:model GetFilterOKBodyAO0RoomEphemeralAllOf0
*/
type GetFilterOKBodyAO0RoomEphemeralAllOf0 struct {

	// The maximum number of events to return.
	Limit int64 `json:"limit,omitempty"`

	// A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the ``'senders'`` filter.
	NotSenders []string `json:"not_senders"`

	// A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the ``'types'`` filter. A '*' can be used as a wildcard to match any sequence of characters.
	NotTypes []string `json:"not_types"`

	// A list of senders IDs to include. If this list is absent then all senders are included.
	Senders []string `json:"senders"`

	// A list of event types to include. If this list is absent then all event types are included. A ``'*'`` can be used as a wildcard to match any sequence of characters.
	Types []string `json:"types"`

	// If ``true``, includes only events with a ``url`` key in their content. If ``false``, excludes those events. If omitted, ``url`` key is not considered for filtering.
	ContainsURL bool `json:"contains_url,omitempty"`

	// If ``true``, sends all membership events for all events, even if they have already
	// been sent to the client. Does not
	// apply unless ``lazy_load_members`` is ``true``. See
	// `Lazy-loading room members <#lazy-loading-room-members>`_
	// for more information. Defaults to ``false``.
	IncludeRedundantMembers bool `json:"include_redundant_members,omitempty"`

	// If ``true``, enables lazy-loading of membership events. See
	// `Lazy-loading room members <#lazy-loading-room-members>`_
	// for more information. Defaults to ``false``.
	LazyLoadMembers bool `json:"lazy_load_members,omitempty"`

	// A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the ``'rooms'`` filter.
	NotRooms []string `json:"not_rooms"`

	// A list of room IDs to include. If this list is absent then all rooms are included.
	Rooms []string `json:"rooms"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (o *GetFilterOKBodyAO0RoomEphemeralAllOf0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Limit int64 `json:"limit,omitempty"`

		NotSenders []string `json:"not_senders"`

		NotTypes []string `json:"not_types"`

		Senders []string `json:"senders"`

		Types []string `json:"types"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	o.Limit = dataAO0.Limit

	o.NotSenders = dataAO0.NotSenders

	o.NotTypes = dataAO0.NotTypes

	o.Senders = dataAO0.Senders

	o.Types = dataAO0.Types

	// AO1
	var dataAO1 struct {
		ContainsURL bool `json:"contains_url,omitempty"`

		IncludeRedundantMembers bool `json:"include_redundant_members,omitempty"`

		LazyLoadMembers bool `json:"lazy_load_members,omitempty"`

		NotRooms []string `json:"not_rooms"`

		Rooms []string `json:"rooms"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	o.ContainsURL = dataAO1.ContainsURL

	o.IncludeRedundantMembers = dataAO1.IncludeRedundantMembers

	o.LazyLoadMembers = dataAO1.LazyLoadMembers

	o.NotRooms = dataAO1.NotRooms

	o.Rooms = dataAO1.Rooms

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (o GetFilterOKBodyAO0RoomEphemeralAllOf0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Limit int64 `json:"limit,omitempty"`

		NotSenders []string `json:"not_senders"`

		NotTypes []string `json:"not_types"`

		Senders []string `json:"senders"`

		Types []string `json:"types"`
	}

	dataAO0.Limit = o.Limit

	dataAO0.NotSenders = o.NotSenders

	dataAO0.NotTypes = o.NotTypes

	dataAO0.Senders = o.Senders

	dataAO0.Types = o.Types

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		ContainsURL bool `json:"contains_url,omitempty"`

		IncludeRedundantMembers bool `json:"include_redundant_members,omitempty"`

		LazyLoadMembers bool `json:"lazy_load_members,omitempty"`

		NotRooms []string `json:"not_rooms"`

		Rooms []string `json:"rooms"`
	}

	dataAO1.ContainsURL = o.ContainsURL

	dataAO1.IncludeRedundantMembers = o.IncludeRedundantMembers

	dataAO1.LazyLoadMembers = o.LazyLoadMembers

	dataAO1.NotRooms = o.NotRooms

	dataAO1.Rooms = o.Rooms

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this get filter o k body a o0 room ephemeral all of0
func (o *GetFilterOKBodyAO0RoomEphemeralAllOf0) Validate(formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (o *GetFilterOKBodyAO0RoomEphemeralAllOf0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetFilterOKBodyAO0RoomEphemeralAllOf0) UnmarshalBinary(b []byte) error {
	var res GetFilterOKBodyAO0RoomEphemeralAllOf0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetFilterOKBodyAO0RoomStateAllOf0 get filter o k body a o0 room state all of0
swagger:model GetFilterOKBodyAO0RoomStateAllOf0
*/
type GetFilterOKBodyAO0RoomStateAllOf0 struct {

	// The maximum number of events to return.
	Limit int64 `json:"limit,omitempty"`

	// A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the ``'senders'`` filter.
	NotSenders []string `json:"not_senders"`

	// A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the ``'types'`` filter. A '*' can be used as a wildcard to match any sequence of characters.
	NotTypes []string `json:"not_types"`

	// A list of senders IDs to include. If this list is absent then all senders are included.
	Senders []string `json:"senders"`

	// A list of event types to include. If this list is absent then all event types are included. A ``'*'`` can be used as a wildcard to match any sequence of characters.
	Types []string `json:"types"`

	// If ``true``, includes only events with a ``url`` key in their content. If ``false``, excludes those events. If omitted, ``url`` key is not considered for filtering.
	ContainsURL bool `json:"contains_url,omitempty"`

	// If ``true``, sends all membership events for all events, even if they have already
	// been sent to the client. Does not
	// apply unless ``lazy_load_members`` is ``true``. See
	// `Lazy-loading room members <#lazy-loading-room-members>`_
	// for more information. Defaults to ``false``.
	IncludeRedundantMembers bool `json:"include_redundant_members,omitempty"`

	// If ``true``, enables lazy-loading of membership events. See
	// `Lazy-loading room members <#lazy-loading-room-members>`_
	// for more information. Defaults to ``false``.
	LazyLoadMembers bool `json:"lazy_load_members,omitempty"`

	// A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the ``'rooms'`` filter.
	NotRooms []string `json:"not_rooms"`

	// A list of room IDs to include. If this list is absent then all rooms are included.
	Rooms []string `json:"rooms"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (o *GetFilterOKBodyAO0RoomStateAllOf0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Limit int64 `json:"limit,omitempty"`

		NotSenders []string `json:"not_senders"`

		NotTypes []string `json:"not_types"`

		Senders []string `json:"senders"`

		Types []string `json:"types"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	o.Limit = dataAO0.Limit

	o.NotSenders = dataAO0.NotSenders

	o.NotTypes = dataAO0.NotTypes

	o.Senders = dataAO0.Senders

	o.Types = dataAO0.Types

	// AO1
	var dataAO1 struct {
		ContainsURL bool `json:"contains_url,omitempty"`

		IncludeRedundantMembers bool `json:"include_redundant_members,omitempty"`

		LazyLoadMembers bool `json:"lazy_load_members,omitempty"`

		NotRooms []string `json:"not_rooms"`

		Rooms []string `json:"rooms"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	o.ContainsURL = dataAO1.ContainsURL

	o.IncludeRedundantMembers = dataAO1.IncludeRedundantMembers

	o.LazyLoadMembers = dataAO1.LazyLoadMembers

	o.NotRooms = dataAO1.NotRooms

	o.Rooms = dataAO1.Rooms

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (o GetFilterOKBodyAO0RoomStateAllOf0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Limit int64 `json:"limit,omitempty"`

		NotSenders []string `json:"not_senders"`

		NotTypes []string `json:"not_types"`

		Senders []string `json:"senders"`

		Types []string `json:"types"`
	}

	dataAO0.Limit = o.Limit

	dataAO0.NotSenders = o.NotSenders

	dataAO0.NotTypes = o.NotTypes

	dataAO0.Senders = o.Senders

	dataAO0.Types = o.Types

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		ContainsURL bool `json:"contains_url,omitempty"`

		IncludeRedundantMembers bool `json:"include_redundant_members,omitempty"`

		LazyLoadMembers bool `json:"lazy_load_members,omitempty"`

		NotRooms []string `json:"not_rooms"`

		Rooms []string `json:"rooms"`
	}

	dataAO1.ContainsURL = o.ContainsURL

	dataAO1.IncludeRedundantMembers = o.IncludeRedundantMembers

	dataAO1.LazyLoadMembers = o.LazyLoadMembers

	dataAO1.NotRooms = o.NotRooms

	dataAO1.Rooms = o.Rooms

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this get filter o k body a o0 room state all of0
func (o *GetFilterOKBodyAO0RoomStateAllOf0) Validate(formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (o *GetFilterOKBodyAO0RoomStateAllOf0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetFilterOKBodyAO0RoomStateAllOf0) UnmarshalBinary(b []byte) error {
	var res GetFilterOKBodyAO0RoomStateAllOf0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetFilterOKBodyAO0RoomTimelineAllOf0 get filter o k body a o0 room timeline all of0
swagger:model GetFilterOKBodyAO0RoomTimelineAllOf0
*/
type GetFilterOKBodyAO0RoomTimelineAllOf0 struct {

	// The maximum number of events to return.
	Limit int64 `json:"limit,omitempty"`

	// A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the ``'senders'`` filter.
	NotSenders []string `json:"not_senders"`

	// A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the ``'types'`` filter. A '*' can be used as a wildcard to match any sequence of characters.
	NotTypes []string `json:"not_types"`

	// A list of senders IDs to include. If this list is absent then all senders are included.
	Senders []string `json:"senders"`

	// A list of event types to include. If this list is absent then all event types are included. A ``'*'`` can be used as a wildcard to match any sequence of characters.
	Types []string `json:"types"`

	// If ``true``, includes only events with a ``url`` key in their content. If ``false``, excludes those events. If omitted, ``url`` key is not considered for filtering.
	ContainsURL bool `json:"contains_url,omitempty"`

	// If ``true``, sends all membership events for all events, even if they have already
	// been sent to the client. Does not
	// apply unless ``lazy_load_members`` is ``true``. See
	// `Lazy-loading room members <#lazy-loading-room-members>`_
	// for more information. Defaults to ``false``.
	IncludeRedundantMembers bool `json:"include_redundant_members,omitempty"`

	// If ``true``, enables lazy-loading of membership events. See
	// `Lazy-loading room members <#lazy-loading-room-members>`_
	// for more information. Defaults to ``false``.
	LazyLoadMembers bool `json:"lazy_load_members,omitempty"`

	// A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the ``'rooms'`` filter.
	NotRooms []string `json:"not_rooms"`

	// A list of room IDs to include. If this list is absent then all rooms are included.
	Rooms []string `json:"rooms"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (o *GetFilterOKBodyAO0RoomTimelineAllOf0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Limit int64 `json:"limit,omitempty"`

		NotSenders []string `json:"not_senders"`

		NotTypes []string `json:"not_types"`

		Senders []string `json:"senders"`

		Types []string `json:"types"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	o.Limit = dataAO0.Limit

	o.NotSenders = dataAO0.NotSenders

	o.NotTypes = dataAO0.NotTypes

	o.Senders = dataAO0.Senders

	o.Types = dataAO0.Types

	// AO1
	var dataAO1 struct {
		ContainsURL bool `json:"contains_url,omitempty"`

		IncludeRedundantMembers bool `json:"include_redundant_members,omitempty"`

		LazyLoadMembers bool `json:"lazy_load_members,omitempty"`

		NotRooms []string `json:"not_rooms"`

		Rooms []string `json:"rooms"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	o.ContainsURL = dataAO1.ContainsURL

	o.IncludeRedundantMembers = dataAO1.IncludeRedundantMembers

	o.LazyLoadMembers = dataAO1.LazyLoadMembers

	o.NotRooms = dataAO1.NotRooms

	o.Rooms = dataAO1.Rooms

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (o GetFilterOKBodyAO0RoomTimelineAllOf0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Limit int64 `json:"limit,omitempty"`

		NotSenders []string `json:"not_senders"`

		NotTypes []string `json:"not_types"`

		Senders []string `json:"senders"`

		Types []string `json:"types"`
	}

	dataAO0.Limit = o.Limit

	dataAO0.NotSenders = o.NotSenders

	dataAO0.NotTypes = o.NotTypes

	dataAO0.Senders = o.Senders

	dataAO0.Types = o.Types

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		ContainsURL bool `json:"contains_url,omitempty"`

		IncludeRedundantMembers bool `json:"include_redundant_members,omitempty"`

		LazyLoadMembers bool `json:"lazy_load_members,omitempty"`

		NotRooms []string `json:"not_rooms"`

		Rooms []string `json:"rooms"`
	}

	dataAO1.ContainsURL = o.ContainsURL

	dataAO1.IncludeRedundantMembers = o.IncludeRedundantMembers

	dataAO1.LazyLoadMembers = o.LazyLoadMembers

	dataAO1.NotRooms = o.NotRooms

	dataAO1.Rooms = o.Rooms

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this get filter o k body a o0 room timeline all of0
func (o *GetFilterOKBodyAO0RoomTimelineAllOf0) Validate(formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (o *GetFilterOKBodyAO0RoomTimelineAllOf0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetFilterOKBodyAO0RoomTimelineAllOf0) UnmarshalBinary(b []byte) error {
	var res GetFilterOKBodyAO0RoomTimelineAllOf0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
