// Code generated by go-swagger; DO NOT EDIT.

package open_id

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"

	strfmt "github.com/go-openapi/strfmt"
)

// RequestOpenIDTokenReader is a Reader for the RequestOpenIDToken structure.
type RequestOpenIDTokenReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *RequestOpenIDTokenReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewRequestOpenIDTokenOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 429:
		result := NewRequestOpenIDTokenTooManyRequests()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result

	default:
		return nil, runtime.NewAPIError("unknown error", response, response.Code())
	}
}

// NewRequestOpenIDTokenOK creates a RequestOpenIDTokenOK with default headers values
func NewRequestOpenIDTokenOK() *RequestOpenIDTokenOK {
	return &RequestOpenIDTokenOK{}
}

/*RequestOpenIDTokenOK handles this case with default header values.

OpenID token information. This response is nearly compatible with the
response documented in the `OpenID 1.0 Specification <http://openid.net/specs/openid-connect-core-1_0.html#TokenResponse>`_
with the only difference being the lack of an ``id_token``. Instead,
the Matrix homeserver's name is provided.
*/
type RequestOpenIDTokenOK struct {
	Payload *RequestOpenIDTokenOKBody
}

func (o *RequestOpenIDTokenOK) Error() string {
	return fmt.Sprintf("[POST /_matrix/client/unstable/user/{userId}/openid/request_token][%d] requestOpenIdTokenOK  %+v", 200, o.Payload)
}

func (o *RequestOpenIDTokenOK) GetPayload() *RequestOpenIDTokenOKBody {
	return o.Payload
}

func (o *RequestOpenIDTokenOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(RequestOpenIDTokenOKBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewRequestOpenIDTokenTooManyRequests creates a RequestOpenIDTokenTooManyRequests with default headers values
func NewRequestOpenIDTokenTooManyRequests() *RequestOpenIDTokenTooManyRequests {
	return &RequestOpenIDTokenTooManyRequests{}
}

/*RequestOpenIDTokenTooManyRequests handles this case with default header values.

This request was rate-limited.
*/
type RequestOpenIDTokenTooManyRequests struct {
	Payload *RequestOpenIDTokenTooManyRequestsBody
}

func (o *RequestOpenIDTokenTooManyRequests) Error() string {
	return fmt.Sprintf("[POST /_matrix/client/unstable/user/{userId}/openid/request_token][%d] requestOpenIdTokenTooManyRequests  %+v", 429, o.Payload)
}

func (o *RequestOpenIDTokenTooManyRequests) GetPayload() *RequestOpenIDTokenTooManyRequestsBody {
	return o.Payload
}

func (o *RequestOpenIDTokenTooManyRequests) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(RequestOpenIDTokenTooManyRequestsBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*RequestOpenIDTokenOKBody request open ID token o k body
swagger:model RequestOpenIDTokenOKBody
*/
type RequestOpenIDTokenOKBody struct {

	// An access token the consumer may use to verify the identity of
	// the person who generated the token. This is given to the federation
	// API ``GET /openid/userinfo`` to verify the user's identity.
	// Required: true
	AccessToken *string `json:"access_token"`

	// The number of seconds before this token expires and a new one must
	// be generated.
	// Required: true
	ExpiresIn *int64 `json:"expires_in"`

	// The homeserver domain the consumer should use when attempting to
	// verify the user's identity.
	// Required: true
	MatrixServerName *string `json:"matrix_server_name"`

	// The string ``Bearer``.
	// Required: true
	TokenType *string `json:"token_type"`
}

// Validate validates this request open ID token o k body
func (o *RequestOpenIDTokenOKBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccessToken(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpiresIn(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMatrixServerName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTokenType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RequestOpenIDTokenOKBody) validateAccessToken(formats strfmt.Registry) error {

	if err := validate.Required("requestOpenIdTokenOK"+"."+"access_token", "body", o.AccessToken); err != nil {
		return err
	}

	return nil
}

func (o *RequestOpenIDTokenOKBody) validateExpiresIn(formats strfmt.Registry) error {

	if err := validate.Required("requestOpenIdTokenOK"+"."+"expires_in", "body", o.ExpiresIn); err != nil {
		return err
	}

	return nil
}

func (o *RequestOpenIDTokenOKBody) validateMatrixServerName(formats strfmt.Registry) error {

	if err := validate.Required("requestOpenIdTokenOK"+"."+"matrix_server_name", "body", o.MatrixServerName); err != nil {
		return err
	}

	return nil
}

func (o *RequestOpenIDTokenOKBody) validateTokenType(formats strfmt.Registry) error {

	if err := validate.Required("requestOpenIdTokenOK"+"."+"token_type", "body", o.TokenType); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RequestOpenIDTokenOKBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RequestOpenIDTokenOKBody) UnmarshalBinary(b []byte) error {
	var res RequestOpenIDTokenOKBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RequestOpenIDTokenTooManyRequestsBody The rate limit was reached for this request
swagger:model RequestOpenIDTokenTooManyRequestsBody
*/
type RequestOpenIDTokenTooManyRequestsBody struct {

	// The M_LIMIT_EXCEEDED error code
	// Required: true
	Errcode *string `json:"errcode"`

	// A human-readable error message.
	Error string `json:"error,omitempty"`

	// The amount of time in milliseconds the client should wait
	// before trying the request again.
	RetryAfterMs int64 `json:"retry_after_ms,omitempty"`
}

// Validate validates this request open ID token too many requests body
func (o *RequestOpenIDTokenTooManyRequestsBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrcode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RequestOpenIDTokenTooManyRequestsBody) validateErrcode(formats strfmt.Registry) error {

	if err := validate.Required("requestOpenIdTokenTooManyRequests"+"."+"errcode", "body", o.Errcode); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RequestOpenIDTokenTooManyRequestsBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RequestOpenIDTokenTooManyRequestsBody) UnmarshalBinary(b []byte) error {
	var res RequestOpenIDTokenTooManyRequestsBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
