// Code generated by go-swagger; DO NOT EDIT.

package end_to_end_encryption

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"

	strfmt "github.com/go-openapi/strfmt"
)

// QueryKeysReader is a Reader for the QueryKeys structure.
type QueryKeysReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *QueryKeysReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewQueryKeysOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil

	default:
		return nil, runtime.NewAPIError("unknown error", response, response.Code())
	}
}

// NewQueryKeysOK creates a QueryKeysOK with default headers values
func NewQueryKeysOK() *QueryKeysOK {
	return &QueryKeysOK{}
}

/*QueryKeysOK handles this case with default header values.

The device information
*/
type QueryKeysOK struct {
	Payload *QueryKeysOKBody
}

func (o *QueryKeysOK) Error() string {
	return fmt.Sprintf("[POST /_matrix/client/unstable/keys/query][%d] queryKeysOK  %+v", 200, o.Payload)
}

func (o *QueryKeysOK) GetPayload() *QueryKeysOKBody {
	return o.Payload
}

func (o *QueryKeysOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(QueryKeysOKBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*DeviceKeysAnon device keys anon
swagger:model DeviceKeysAnon
*/
type DeviceKeysAnon struct {

	// The encryption algorithms supported by this device.
	// Required: true
	Algorithms []string `json:"algorithms"`

	// The ID of the device these keys belong to. Must match the device ID used
	// when logging in.
	// Required: true
	DeviceID *string `json:"device_id"`

	// Public identity keys. The names of the properties should be in the
	// format ``<algorithm>:<device_id>``. The keys themselves should be
	// encoded as specified by the key algorithm.
	// Required: true
	Keys map[string]string `json:"keys"`

	// Signatures for the device key object. A map from user ID, to a map from
	// ``<algorithm>:<device_id>`` to the signature.
	//
	// The signature is calculated using the process described at `Signing
	// JSON`_.
	// Required: true
	Signatures map[string]map[string]string `json:"signatures"`

	// The ID of the user the device belongs to. Must match the user ID used
	// when logging in.
	// Required: true
	UserID *string `json:"user_id"`

	// unsigned
	Unsigned *DeviceKeysAnonUnsigned `json:"unsigned,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (o *DeviceKeysAnon) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Algorithms []string `json:"algorithms"`

		DeviceID *string `json:"device_id"`

		Keys map[string]string `json:"keys"`

		Signatures map[string]map[string]string `json:"signatures"`

		UserID *string `json:"user_id"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	o.Algorithms = dataAO0.Algorithms

	o.DeviceID = dataAO0.DeviceID

	o.Keys = dataAO0.Keys

	o.Signatures = dataAO0.Signatures

	o.UserID = dataAO0.UserID

	// now for regular properties
	var propsDeviceKeysAnon struct {
		Unsigned *DeviceKeysAnonUnsigned `json:"unsigned,omitempty"`
	}
	if err := swag.ReadJSON(raw, &propsDeviceKeysAnon); err != nil {
		return err
	}
	o.Unsigned = propsDeviceKeysAnon.Unsigned

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (o DeviceKeysAnon) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 1)

	var dataAO0 struct {
		Algorithms []string `json:"algorithms"`

		DeviceID *string `json:"device_id"`

		Keys map[string]string `json:"keys"`

		Signatures map[string]map[string]string `json:"signatures"`

		UserID *string `json:"user_id"`
	}

	dataAO0.Algorithms = o.Algorithms

	dataAO0.DeviceID = o.DeviceID

	dataAO0.Keys = o.Keys

	dataAO0.Signatures = o.Signatures

	dataAO0.UserID = o.UserID

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	// now for regular properties
	var propsDeviceKeysAnon struct {
		Unsigned *DeviceKeysAnonUnsigned `json:"unsigned,omitempty"`
	}
	propsDeviceKeysAnon.Unsigned = o.Unsigned

	jsonDataPropsDeviceKeysAnon, errDeviceKeysAnon := swag.WriteJSON(propsDeviceKeysAnon)
	if errDeviceKeysAnon != nil {
		return nil, errDeviceKeysAnon
	}
	_parts = append(_parts, jsonDataPropsDeviceKeysAnon)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this device keys anon
func (o *DeviceKeysAnon) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAlgorithms(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDeviceID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateKeys(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSignatures(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUserID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUnsigned(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *DeviceKeysAnon) validateUnsigned(formats strfmt.Registry) error {

	if swag.IsZero(o.Unsigned) { // not required
		return nil
	}

	if o.Unsigned != nil {
		if err := o.Unsigned.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("unsigned")
			}
			return err
		}
	}

	return nil
}

func (o *DeviceKeysAnon) validateAlgorithms(formats strfmt.Registry) error {

	if err := validate.Required("algorithms", "body", o.Algorithms); err != nil {
		return err
	}

	return nil
}

func (o *DeviceKeysAnon) validateDeviceID(formats strfmt.Registry) error {

	if err := validate.Required("device_id", "body", o.DeviceID); err != nil {
		return err
	}

	return nil
}

func (o *DeviceKeysAnon) validateKeys(formats strfmt.Registry) error {

	return nil
}

func (o *DeviceKeysAnon) validateSignatures(formats strfmt.Registry) error {

	for k := range o.Signatures {

		if err := validate.Required("signatures"+"."+k, "body", o.Signatures[k]); err != nil {
			return err
		}

	}

	return nil
}

func (o *DeviceKeysAnon) validateUserID(formats strfmt.Registry) error {

	if err := validate.Required("user_id", "body", o.UserID); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *DeviceKeysAnon) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *DeviceKeysAnon) UnmarshalBinary(b []byte) error {
	var res DeviceKeysAnon
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*DeviceKeysAnonUnsigned UnsignedDeviceInfo
//
// Additional data added to the device key information
// by intermediate servers, and not covered by the
// signatures.
swagger:model DeviceKeysAnonUnsigned
*/
type DeviceKeysAnonUnsigned struct {

	// The display name which the user set on the device.
	DeviceDisplayName string `json:"device_display_name,omitempty"`
}

// Validate validates this device keys anon unsigned
func (o *DeviceKeysAnonUnsigned) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *DeviceKeysAnonUnsigned) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *DeviceKeysAnonUnsigned) UnmarshalBinary(b []byte) error {
	var res DeviceKeysAnonUnsigned
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*QueryKeysBody query keys body
swagger:model QueryKeysBody
*/
type QueryKeysBody struct {

	// The keys to be downloaded. A map from user ID, to a list of
	// device IDs, or to an empty list to indicate all devices for the
	// corresponding user.
	// Required: true
	DeviceKeys map[string][]string `json:"device_keys"`

	// The time (in milliseconds) to wait when downloading keys from
	// remote servers. 10 seconds is the recommended default.
	Timeout int64 `json:"timeout,omitempty"`

	// If the client is fetching keys as a result of a device update received
	// in a sync request, this should be the 'since' token of that sync request,
	// or any later sync token. This allows the server to ensure its response
	// contains the keys advertised by the notification in that sync.
	Token string `json:"token,omitempty"`
}

// Validate validates this query keys body
func (o *QueryKeysBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDeviceKeys(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *QueryKeysBody) validateDeviceKeys(formats strfmt.Registry) error {

	return nil
}

// MarshalBinary interface implementation
func (o *QueryKeysBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *QueryKeysBody) UnmarshalBinary(b []byte) error {
	var res QueryKeysBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*QueryKeysOKBody query keys o k body
swagger:model QueryKeysOKBody
*/
type QueryKeysOKBody struct {

	// Information on the queried devices. A map from user ID, to a
	// map from device ID to device information.  For each device,
	// the information returned will be the same as uploaded via
	// ``/keys/upload``, with the addition of an ``unsigned``
	// property.
	DeviceKeys map[string]map[string]DeviceKeysAnon `json:"device_keys,omitempty"`

	// If any remote homeservers could not be reached, they are
	// recorded here. The names of the properties are the names of
	// the unreachable servers.
	//
	// If the homeserver could be reached, but the user or device
	// was unknown, no failure is recorded. Instead, the corresponding
	// user or device is missing from the ``device_keys`` result.
	Failures map[string]interface{} `json:"failures,omitempty"`
}

// Validate validates this query keys o k body
func (o *QueryKeysOKBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDeviceKeys(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *QueryKeysOKBody) validateDeviceKeys(formats strfmt.Registry) error {

	if swag.IsZero(o.DeviceKeys) { // not required
		return nil
	}

	for k := range o.DeviceKeys {

		for kk := range o.DeviceKeys[k] {

			if swag.IsZero(o.DeviceKeys[k][kk]) { // not required
				continue
			}
			if val, ok := o.DeviceKeys[k][kk]; ok {
				if err := val.Validate(formats); err != nil {
					return err
				}
			}

		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *QueryKeysOKBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *QueryKeysOKBody) UnmarshalBinary(b []byte) error {
	var res QueryKeysOKBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
